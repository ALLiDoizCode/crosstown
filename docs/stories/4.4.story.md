# Story 4.4: ILP Payment Verification (BLS Pattern)

## Status

Done

## Story

**As a** relay operator,
**I want** a Business Logic Server that verifies ILP payments before accepting writes,
**so that** only paid events are stored.

## Acceptance Criteria

1. BLS HTTP endpoint `/handle-payment` accepts JSON payment requests from connector
2. BLS extracts TOON-encoded event from base64 data field
3. BLS verifies payment amount meets minimum pricing requirements
4. BLS returns JSON accept/reject response for connector to create ILP packets
5. On accept, event is passed to relay for storage
6. Health check endpoint `/health` returns server status
7. Unit tests verify payment verification and accept/reject flows

## Tasks / Subtasks

- [x] Task 1: Add Hono HTTP framework dependency (AC: 1)
  - [x] Add `hono` (^4.0.0) to `packages/relay/package.json` dependencies
  - [x] Run `pnpm install` to update lockfile
  - [x] Verify build still passes with new dependency

- [x] Task 2: Define BLS types and interfaces (AC: 1, 3, 4)
  - [x] Create `packages/relay/src/bls/types.ts`
  - [x] Define `BlsConfig` interface:
    ```typescript
    interface BlsConfig {
      /** Base price per byte for event storage (used for simple pricing) */
      basePricePerByte: bigint;
    }
    ```
  - [x] Define `HandlePaymentRequest` interface for incoming requests:
    ```typescript
    interface HandlePaymentRequest {
      /** Payment amount as string (parsed to bigint) */
      amount: string;
      /** ILP destination address */
      destination: string;
      /** Base64-encoded TOON Nostr event */
      data: string;
      /** Source ILP address */
      sourceAccount?: string;
    }
    ```
  - [x] Define `HandlePaymentResponse` interface for accept case:
    ```typescript
    interface HandlePaymentAcceptResponse {
      accept: true;
      /** Base64-encoded fulfillment (SHA-256 of event.id) */
      fulfillment: string;
      metadata?: {
        eventId: string;
        storedAt: number;
      };
    }
    ```
  - [x] Define `HandlePaymentRejectResponse` interface for reject case:
    ```typescript
    interface HandlePaymentRejectResponse {
      accept: false;
      /** ILP error code (F00, F06, etc.) */
      code: string;
      /** Human-readable error message */
      message: string;
      metadata?: {
        required?: string;
        received?: string;
      };
    }
    ```
  - [x] Define `BlsError` class extending `RelayError` with code `'BLS_ERROR'`

- [x] Task 3: Create BusinessLogicServer class (AC: 1, 4, 5, 6)
  - [x] Create `packages/relay/src/bls/BusinessLogicServer.ts`
  - [x] Import Hono for HTTP server
  - [x] Import `decodeEventFromToon` from toon module
  - [x] Implement `BusinessLogicServer` class:
    ```typescript
    class BusinessLogicServer {
      constructor(
        config: BlsConfig,
        eventStore: EventStore
      )
    }
    ```
  - [x] Create Hono app instance as private property
  - [x] Implement POST `/handle-payment` endpoint handler
  - [x] Implement GET `/health` endpoint handler
  - [x] Add `getApp(): Hono` method for testing/composition
  - [x] Add `start(port: number): void` method to run server

- [x] Task 4: Implement /handle-payment request flow (AC: 1, 2, 3, 4, 5)
  - [x] Parse incoming JSON request body as `HandlePaymentRequest`
  - [x] Validate required fields (amount, destination, data)
  - [x] Decode base64 data field to Uint8Array
  - [x] Call `decodeEventFromToon(data)` to extract Nostr event
  - [x] Verify event signature using `nostr-tools` `verifyEvent()`
  - [x] Calculate price: `BigInt(toonBytes.length) * config.basePricePerByte`
  - [x] Compare `BigInt(request.amount)` with calculated price
  - [x] If amount >= price:
    - Store event in EventStore
    - Generate fulfillment: `SHA256(event.id)` as base64
    - Return `HandlePaymentAcceptResponse` with 200 status
  - [x] If amount < price:
    - Return `HandlePaymentRejectResponse` with code `'F06'` (Insufficient Amount)
  - [x] On invalid TOON/signature:
    - Return `HandlePaymentRejectResponse` with code `'F00'` (Bad Request)

- [x] Task 5: Implement /health endpoint (AC: 6)
  - [x] Return JSON with status, timestamp
  - [x] Include relay ready state if available

- [x] Task 6: Create fulfillment generation utility (AC: 4)
  - [x] Create `generateFulfillment(eventId: string): string` function
  - [x] Compute SHA-256 hash of event ID
  - [x] Return as base64-encoded string
  - [x] Note: Sender must use SHA256(SHA256(eventId)) as condition

- [x] Task 7: Create error code constants (AC: 4)
  - [x] Define ILP error code constants:
    ```typescript
    const ILP_ERROR_CODES = {
      BAD_REQUEST: 'F00',
      INSUFFICIENT_AMOUNT: 'F06',
      INTERNAL_ERROR: 'T00',
    } as const;
    ```

- [x] Task 8: Update module exports (AC: 1-6)
  - [x] Create `packages/relay/src/bls/index.ts`
  - [x] Export `BusinessLogicServer`, `BlsConfig`, `BlsError`
  - [x] Export request/response types
  - [x] Export `generateFulfillment` utility
  - [x] Export `ILP_ERROR_CODES`
  - [x] Export from `packages/relay/src/index.ts`

- [x] Task 9: Write unit tests for BusinessLogicServer (AC: 1-7)
  - [x] Create `packages/relay/src/bls/BusinessLogicServer.test.ts`
  - [x] Test POST /handle-payment accepts valid paid request
  - [x] Test POST /handle-payment rejects insufficient payment with F06
  - [x] Test POST /handle-payment rejects invalid TOON data with F00
  - [x] Test POST /handle-payment rejects invalid event signature with F00
  - [x] Test event is stored in EventStore on success
  - [x] Test event is NOT stored on failure
  - [x] Test fulfillment is correctly generated from event.id
  - [x] Test response metadata includes eventId and storedAt
  - [x] Test GET /health returns status
  - [x] Use mocked EventStore for isolation

- [x] Task 10: Write integration tests (AC: 1-7)
  - [x] Test full flow: JSON request -> TOON decode -> pricing -> storage
  - [x] Test with SqliteEventStore
  - [x] Verify event retrievable after successful payment
  - [x] Test with real signed Nostr events (using nostr-tools to create)

## Dev Notes

### Architecture: Connector Calls BLS via HTTP
[Source: docs/AGENT-RUNTIME-INTEGRATION.md]

**Important:** The ILP connector (agent-runtime) handles all ILP packet parsing and serialization. The BLS receives pre-parsed JSON and returns JSON responses. The connector then creates the appropriate ILP Fulfill or Reject packets.

```
ILP Prepare arrives at connector
        │
        ▼
Connector extracts: amount, destination, data (TOON event)
        │
        ▼
POST /handle-payment to BLS
{
  "amount": "50000",
  "destination": "g.agent.alice",
  "data": "<base64 TOON-encoded Nostr event>",
  "sourceAccount": "g.agent.bob"
}
        │
        ▼
BLS processes:
  1. Decode base64 → TOON bytes
  2. Decode TOON → Nostr event
  3. Verify event signature (NIP-01)
  4. Calculate price (bytes * pricePerByte)
  5. Check: amount ≥ price?
        │
        ├─── YES ───► Store event
        │             Return: { "accept": true, "fulfillment": "..." }
        │
        └─── NO ────► Return: { "accept": false, "code": "F06", "message": "..." }
        │
        ▼
Connector returns ILP Fulfill or Reject to sender
```

### Fulfillment Generation
[Source: docs/AGENT-RUNTIME-INTEGRATION.md#bls-implementation]

The fulfillment is derived deterministically from the event ID:

```typescript
import { createHash } from 'crypto';

function generateFulfillment(eventId: string): string {
  const hash = createHash('sha256').update(eventId).digest();
  return hash.toString('base64');
}
```

**Note:** The sender must know to use `SHA256(SHA256(eventId))` as the condition in their ILP Prepare packet. This is a pre-agreed protocol between sender and BLS.

### Scope Boundaries

**In Scope (this story):**
- Basic BLS with `/handle-payment` and `/health` endpoints
- Simple per-byte pricing: `price = bytes * basePricePerByte`
- Event signature verification
- Event storage on successful payment

**Out of Scope (deferred to later stories):**
- **Story 4.5:** Configurable PricingService with per-kind overrides
- **Story 4.6:** Self-write bypass (owner pubkey events bypass payment)

### Previous Story Insights
[Source: docs/stories/4.3.story.md#dev-agent-record]

From Story 4.3 implementation:
- TOON encoding/decoding implemented in `packages/relay/src/toon/` module
- `encodeEventToToon(event: NostrEvent): Uint8Array` and `decodeEventFromToon(data: Uint8Array): NostrEvent` available
- `ToonError` and `ToonEncodeError` classes extend `RelayError`
- Pattern: Create dedicated module directories with index.ts for exports
- Pattern: Use `RelayError` class for relay-specific errors with error codes

### Tech Stack
[Source: docs/architecture/3-tech-stack.md]

| Technology | Version | Purpose |
|------------|---------|---------|
| Hono | 4.x | BLS HTTP endpoints - lightweight, TypeScript-first |
| nostr-tools | 2.x | Event signature verification with `verifyEvent()` |
| Vitest | 1.x | Unit testing |
| TypeScript | 5.3.x | Language |

### Project Structure
[Source: docs/architecture/9-source-tree.md]

Files to create for this story:
```
packages/relay/src/
└── bls/
    ├── index.ts                   # Module exports
    ├── types.ts                   # BlsConfig, request/response types, BlsError
    ├── BusinessLogicServer.ts     # Main BLS class with Hono HTTP endpoints
    └── BusinessLogicServer.test.ts # BLS unit and integration tests
```

### Hono HTTP Framework
[Source: https://hono.dev]

Hono is a lightweight, TypeScript-first HTTP framework:

```typescript
import { Hono } from 'hono';

const app = new Hono();

// JSON body handling
app.post('/handle-payment', async (c) => {
  const body = await c.req.json<HandlePaymentRequest>();

  // Process payment...

  // Return JSON response
  return c.json({
    accept: true,
    fulfillment: 'base64...',
    metadata: { eventId: '...', storedAt: Date.now() }
  });
});

app.get('/health', (c) => {
  return c.json({
    status: 'healthy',
    timestamp: Date.now()
  });
});

// For testing, use app.request()
export { app };
```

### Event Signature Verification
[Source: nostr-tools documentation]

```typescript
import { verifyEvent } from 'nostr-tools/pure';

// Returns true if signature is valid
const isValid = verifyEvent(event);

if (!isValid) {
  return c.json({
    accept: false,
    code: 'F00',
    message: 'Invalid event signature'
  });
}
```

### EventStore Interface
[Source: packages/relay/src/storage/InMemoryEventStore.ts]

```typescript
export interface EventStore {
  store(event: NostrEvent): void;
  get(id: string): NostrEvent | undefined;
  query(filters: Filter[]): NostrEvent[];
  close?(): void;
}
```

BLS will receive an EventStore instance and call `store()` on successful payment.

### Error Handling
[Source: docs/architecture/11-error-handling-strategy.md]

Create `BlsError` class for BLS-specific errors:
```typescript
import { RelayError } from '../storage/index.js';

export class BlsError extends RelayError {
  constructor(message: string, code: string = 'BLS_ERROR') {
    super(message, code);
    this.name = 'BlsError';
  }
}
```

### ILP Error Codes
[Source: ILP RFC specifications]

| Code | Name | When to Use |
|------|------|-------------|
| F00 | Bad Request | Invalid TOON data, malformed request, bad signature |
| F06 | Insufficient Amount | Payment amount < required price |
| T00 | Internal Error | Unexpected server errors |

### Coding Standards
[Source: docs/architecture/12-coding-standards.md]

| Element | Convention | Example |
|---------|------------|---------|
| Files | kebab-case or PascalCase | `BusinessLogicServer.ts` |
| Classes | PascalCase | `BusinessLogicServer` |
| Functions | camelCase | `generateFulfillment` |
| Constants | UPPER_SNAKE_CASE | `ILP_ERROR_CODES` |

### Testing Requirements
[Source: docs/architecture/13-test-strategy-and-standards.md]

**Framework:** Vitest 1.x

**Test File Location:** Co-located with source

**Test Pattern:**
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { generateSecretKey, finalizeEvent } from 'nostr-tools/pure';
import { BusinessLogicServer } from './BusinessLogicServer.js';
import { encodeEventToToon } from '../toon/index.js';
import type { NostrEvent } from 'nostr-tools/pure';

// Helper to create properly signed test events
function createValidSignedEvent(overrides: Partial<NostrEvent> = {}): NostrEvent {
  const sk = generateSecretKey();
  return finalizeEvent({
    kind: 1,
    content: 'test content',
    tags: [],
    created_at: Math.floor(Date.now() / 1000),
    ...overrides,
  }, sk);
}

describe('BusinessLogicServer', () => {
  let bls: BusinessLogicServer;
  let mockEventStore: EventStore;

  beforeEach(() => {
    mockEventStore = {
      store: vi.fn(),
      get: vi.fn(),
      query: vi.fn(),
      close: vi.fn(),
    };
    bls = new BusinessLogicServer(
      { basePricePerByte: 10n },
      mockEventStore
    );
  });

  it('should accept payment when amount meets price', async () => {
    const event = createValidSignedEvent();
    const toonData = encodeEventToToon(event);
    const base64Data = Buffer.from(toonData).toString('base64');

    const response = await bls.getApp().request('/handle-payment', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        amount: '1000000',
        destination: 'g.agent.test',
        data: base64Data,
      }),
    });

    const json = await response.json();
    expect(json.accept).toBe(true);
    expect(json.fulfillment).toBeDefined();
    expect(mockEventStore.store).toHaveBeenCalledWith(event);
  });

  it('should reject insufficient payment with F06', async () => {
    const event = createValidSignedEvent();
    const toonData = encodeEventToToon(event);
    const base64Data = Buffer.from(toonData).toString('base64');

    const response = await bls.getApp().request('/handle-payment', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        amount: '1', // Too low
        destination: 'g.agent.test',
        data: base64Data,
      }),
    });

    const json = await response.json();
    expect(json.accept).toBe(false);
    expect(json.code).toBe('F06');
    expect(mockEventStore.store).not.toHaveBeenCalled();
  });
});
```

### Security Considerations
[Source: docs/architecture/14-security.md]

- **Event Signature Verification**: Always verify event signature before storing
- **Input Validation**: Validate JSON structure and base64 encoding
- **Integer Overflow**: Use bigint for amount calculations to prevent overflow
- **Base64 Decoding**: Handle invalid base64 gracefully

### BigInt for Amounts
[Source: ILP specification guidance]

ILP amounts can be very large (up to 2^64-1). Use bigint for all amount operations:

```typescript
// Request amount comes as string, parse to bigint
const amount = BigInt(request.amount);
const toonBytes = Buffer.from(request.data, 'base64');
const price = BigInt(toonBytes.length) * config.basePricePerByte;

if (amount >= price) {
  // Accept payment
}
```

## File List

| File | Status | Description |
|------|--------|-------------|
| `packages/relay/package.json` | Modified | Added hono ^4.0.0 dependency |
| `packages/relay/src/bls/types.ts` | Created | BlsConfig, request/response types, BlsError, ILP_ERROR_CODES |
| `packages/relay/src/bls/BusinessLogicServer.ts` | Created | Main BLS class with Hono HTTP endpoints and generateFulfillment |
| `packages/relay/src/bls/BusinessLogicServer.test.ts` | Created | 21 unit and integration tests |
| `packages/relay/src/bls/index.ts` | Created | Module exports |
| `packages/relay/src/index.ts` | Modified | Export BLS module types and classes |
| `pnpm-lock.yaml` | Modified | Updated with hono dependency |

## Dev Agent Record

### Agent Model Used

Claude Opus 4.5 (claude-opus-4-5-20251101)

### Debug Log References

None - implementation completed without issues.

### Completion Notes

- Implemented BusinessLogicServer with Hono HTTP framework
- POST /handle-payment endpoint verifies ILP payments before storing events
- GET /health endpoint returns server status with timestamp
- generateFulfillment() utility creates SHA-256 hash of event.id as base64
- All 21 tests pass (unit tests with mocked EventStore, integration tests with SqliteEventStore)
- Full test suite: 488 tests passing across all packages

## QA Results

### Review Date: 2026-02-06

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

Excellent implementation of the Business Logic Server. The code is well-structured, follows established patterns from previous stories, and demonstrates strong TypeScript practices. Key strengths:

- Clean separation of concerns: types in `types.ts`, implementation in `BusinessLogicServer.ts`
- Proper use of bigint for ILP amounts (prevents integer overflow)
- Comprehensive error handling with appropriate ILP error codes (F00, F06, T00)
- Strong validation of inputs at boundary (base64 decoding, TOON parsing, signature verification)
- Uses Hono's testable architecture (`getApp()` for testing)

### Refactoring Performed

None required. The implementation is clean and follows project standards.

### Compliance Check

- Coding Standards: ✓ Follows naming conventions (PascalCase classes, camelCase functions, UPPER_SNAKE_CASE constants)
- Project Structure: ✓ Module organized with index.ts exports, co-located tests
- Testing Strategy: ✓ Unit tests with mocked EventStore, integration tests with SqliteEventStore
- All ACs Met: ✓ All 7 acceptance criteria fully implemented and tested

### Improvements Checklist

- [x] All required functionality implemented
- [x] Event signature verification before storage (security requirement met)
- [x] Proper bigint usage for amounts (no overflow risk)
- [x] Comprehensive test coverage (21 tests)
- [ ] Consider adding request body size validation (optional, low priority - could add a maxPayloadSize config option to prevent DoS via large payloads)
- [ ] Consider adding structured logging instead of console.log in start() method (optional, low priority - only affects server startup diagnostic)

### Security Review

**Strong security posture:**
- Event signature verification using `verifyEvent()` before any storage operation
- Input validation for all required fields before processing
- Base64 decoding with proper error handling
- TOON decoding with error propagation
- BigInt used for amount calculations (prevents integer overflow attacks)
- No secrets logged or stored

**No security concerns identified.**

### Performance Considerations

- In-memory EventStore used in unit tests (fast)
- SQLite EventStore used in integration tests (realistic)
- No blocking operations in payment handler
- SHA-256 fulfillment generation is efficient
- TOON decoding is synchronous but fast for typical event sizes

**No performance concerns for MVP scope.**

### Files Modified During Review

None. Implementation meets quality standards.

### Gate Status

Gate: PASS → docs/qa/gates/4.4-ilp-payment-verification-bls-pattern.yml

### Recommended Status

✓ Ready for Done

This implementation is solid, well-tested, and follows all project standards. The BLS correctly verifies ILP payments before storing events, generates proper fulfillments, and handles all error cases appropriately. The 21 tests provide excellent coverage of acceptance criteria including edge cases like exact-price payments, insufficient amounts, invalid signatures, and malformed data.

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-06 | 0.1 | Initial story draft | SM |
| 2026-02-06 | 0.2 | Updated to JSON HTTP API pattern per AGENT-RUNTIME-INTEGRATION.md; removed ILP packet parsing (handled by connector); removed PricingService (deferred to 4.5); removed self-write bypass (deferred to 4.6) | SM |
| 2026-02-06 | 0.3 | Added QA Results section; added createValidSignedEvent helper in test examples | SM |
| 2026-02-06 | 1.0 | Implementation complete - BLS with Hono, 21 tests passing, all ACs met | Dev (Claude Opus 4.5) |
