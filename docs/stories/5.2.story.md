# Story 5.2: BLS Docker Image Build Configuration

## Status

Done

## Story

**As a** DevOps engineer,
**I want** a Dockerfile that builds a minimal BLS-only container,
**so that** the image is small, secure, and fast to pull.

## Acceptance Criteria

1. Create `/packages/bls/Dockerfile` with multi-stage build
2. Base image: `node:20-alpine` (smaller than `node:20-slim`)
3. Final image size < 150MB
4. Image exposes only port 3100 (BLS HTTP)
5. `VOLUME /data` declared for persistent storage mount point
6. Health check configured: `GET http://localhost:3100/health` every 30s
7. Non-root user for security (e.g., `node` user)
8. `docker build` succeeds from repo root
9. Container starts and responds to health check

## Tasks / Subtasks

- [x] Task 1: Create multi-stage `packages/bls/Dockerfile` (AC: 1, 2, 3, 7, 8)
  - [x] Stage 1 (`builder`): Use `node:20-alpine` as base
  - [x] Install `pnpm` via `corepack enable && corepack prepare pnpm@latest --activate`
  - [x] Install native build dependencies for `better-sqlite3`: `python3`, `make`, `g++` (Alpine uses musl, so `better-sqlite3` must compile from source)
  - [x] Copy workspace root files: `package.json`, `pnpm-workspace.yaml`, `pnpm-lock.yaml`, `tsconfig.json`
  - [x] Copy only `packages/bls/package.json` (no other packages needed)
  - [x] Copy placeholder `package.json` files for other workspace packages referenced in the lockfile (`packages/core/package.json`, `packages/relay/package.json`, `docker/package.json`) so that `pnpm install --frozen-lockfile` can resolve the full workspace without copying their source code (same pattern as existing `docker/Dockerfile` lines 17-19)
  - [x] Run `pnpm install --frozen-lockfile` to install all workspace deps (lockfile requires full workspace resolution)
  - [x] Copy `packages/bls/` source code (src/, tsconfig.json, tsup.config.ts)
  - [x] Run `pnpm --filter @agent-society/bls build` to produce `dist/`
  - [x] Stage 2 (`production`): Use fresh `node:20-alpine`
  - [x] Install only runtime native dependency for `better-sqlite3` if needed (the compiled `.node` file may need `libstdc++` at runtime on Alpine)
  - [x] Copy built `dist/` from builder stage
  - [x] Copy `node_modules/` from builder stage (only production deps)
  - [x] Copy `package.json` for Node.js module resolution
  - [x] Set `NODE_ENV=production`
  - [x] Create and switch to non-root `node` user (Alpine's `node` image already has this user)
  - [x] Create `/data` directory owned by `node` user

- [x] Task 2: Configure port exposure and volume (AC: 4, 5)
  - [x] Add `EXPOSE 3100` in Dockerfile
  - [x] Add `VOLUME /data` declaration
  - [x] Set default `DATA_DIR=/data` environment variable
  - [x] Set default `BLS_PORT=3100` environment variable

- [x] Task 3: Configure health check (AC: 6)
  - [x] Add `HEALTHCHECK` instruction: `--interval=30s --timeout=5s --start-period=10s --retries=3`
  - [x] Use `wget` for health check (available on Alpine, unlike `curl`): `wget -q --spider http://localhost:3100/health`
  - [x] Alternatively use Node.js one-liner if `wget` is unavailable: `node -e "fetch('http://localhost:3100/health').then(r=>r.ok?process.exit(0):process.exit(1)).catch(()=>process.exit(1))"`

- [x] Task 4: Set the CMD entrypoint (AC: 9)
  - [x] Set `CMD ["node", "dist/entrypoint.js"]`
  - [x] Verify the entrypoint path matches the `tsup` output (`dist/entrypoint.js`)

- [x] Task 5: Add root-level `.dockerignore` file (AC: 3, 8)
  - [x] Create `.dockerignore` at the **repo root** (Docker reads `.dockerignore` from the build context root, which is `.` when running `docker build -f packages/bls/Dockerfile .` — a file at `packages/bls/.dockerignore` would be ignored)
  - [x] Exclude: `node_modules/`, `dist/`, `*.test.ts`, `.git/`, `*.md`, `packages/core/src/`, `packages/relay/src/`, `packages/examples/`, `docs/`, `.github/` (only `packages/bls/` source and workspace root files are needed in the build context)

- [x] Task 6: Verify Docker build from repo root (AC: 8)
  - [x] Run `docker build -f packages/bls/Dockerfile -t agent-society-bls .` from repo root
  - [x] Verify build completes without errors
  - [x] Verify the build context includes necessary files (pnpm-workspace.yaml, pnpm-lock.yaml, etc.)

- [x] Task 7: Verify image size < 150MB (AC: 3)
  - [x] Run `docker images agent-society-bls` and check size
  - [x] If over 150MB, optimize:
    - Remove dev dependencies from final stage
    - Use `pnpm prune --prod` or `npm prune --production`
    - Ensure no source `.ts` files in final image
    - Consider multi-stage COPY with specific paths instead of entire `node_modules/`

- [x] Task 8: Verify container starts and health check passes (AC: 9)
  - [x] Run container with required env vars: `docker run -e NODE_ID=test -e NOSTR_SECRET_KEY=<valid-hex-key> -e ILP_ADDRESS=g.test.node1 -p 3100:3100 agent-society-bls`
  - [x] Verify container starts and logs show BLS running (no native addon load errors for `better-sqlite3` — if `libstdc++` is missing at runtime, the container will crash on startup with a dynamic linking error)
  - [x] Verify `curl http://localhost:3100/health` returns healthy JSON response with nodeId, pubkey, ilpAddress
  - [x] Verify Docker health check reports "healthy" via `docker inspect`
  - [x] Verify SQLite database is created at `/data/events.db` (confirms `better-sqlite3` native addon loaded successfully): `docker exec <container> ls -la /data/`
  - [x] Stop container and verify graceful shutdown

- [x] Task 9: Verify non-root user (AC: 7)
  - [x] Run `docker exec <container> whoami` and verify it returns `node` (not `root`)
  - [x] Verify `/data` directory is writable by `node` user (SQLite db creation)

## Dev Notes

### Previous Story Insights
[Source: docs/stories/5.1.story.md#dev-agent-record]

From Story 5.1 implementation:
- All 734 tests pass (561 original + 166 BLS + 7 entrypoint/config tests)
- BLS package at `packages/bls/` is fully standalone with its own `package.json`, `tsconfig.json`, `tsup.config.ts`
- The BLS package builds independently with `pnpm build` producing `dist/index.js`, `dist/index.d.ts`, `dist/entrypoint.js`, `dist/entrypoint.d.ts`
- The standalone entrypoint (`dist/entrypoint.js`) reads env vars `NODE_ID`, `NOSTR_SECRET_KEY`, `ILP_ADDRESS`, `BLS_PORT`, `BASE_PRICE_PER_BYTE`, `OWNER_PUBKEY`, `DATA_DIR`, `KIND_OVERRIDES`
- Entrypoint uses `@hono/node-server` `serve()` to bind the HTTP server
- Default port is 3100, default data dir is `/data`
- Graceful shutdown handlers for SIGINT/SIGTERM are implemented
- Health endpoint returns `{ status, nodeId, pubkey, ilpAddress, timestamp }`
- `better-sqlite3` is a native addon dependency that requires compilation — on Alpine Linux this means `python3`, `make`, and `g++` must be present during the build stage
- Root `pnpm-workspace.yaml` includes `packages/*` and `docker` — the BLS package is auto-discovered
- Existing Docker container in `docker/Dockerfile` uses `node:20-slim` and builds all packages; the new BLS Dockerfile should be a lean, BLS-only build

### Architecture: BLS Package Dependencies
[Source: packages/bls/package.json]

**Runtime dependencies:**
```json
{
  "@hono/node-server": "^1.14.0",
  "@toon-format/toon": "^1.0.0",
  "better-sqlite3": "^11.0.0",
  "hono": "^4.0.0",
  "nostr-tools": "^2.20.0"
}
```

**Dev dependencies:**
```json
{
  "@types/better-sqlite3": "^7.6.0"
}
```

Key considerations:
- `better-sqlite3` is a native Node.js addon compiled via `node-gyp`. On Alpine (musl libc), it compiles from source (no prebuilt binaries). Build stage needs `python3 make g++`.
- At runtime on Alpine, the compiled `better-sqlite3.node` binary may need `libstdc++`. Alpine's `node:20-alpine` image typically includes this, but verify.
- `nostr-tools` depends on `@noble/curves` and `@noble/ciphers` (pure JS, no native deps).
- `hono` and `@hono/node-server` are pure JS.
- `@toon-format/toon` is pure JS.

### Architecture: Entrypoint
[Source: packages/bls/src/entrypoint.ts]

The entrypoint (`src/entrypoint.ts`, built to `dist/entrypoint.js`):
- Reads required env vars: `NODE_ID`, `NOSTR_SECRET_KEY`, `ILP_ADDRESS`
- Reads optional env vars: `BLS_PORT` (default 3100), `BASE_PRICE_PER_BYTE` (default 10), `OWNER_PUBKEY`, `DATA_DIR` (default `/data`), `KIND_OVERRIDES`
- Creates `SqliteEventStore` at `${DATA_DIR}/events.db`
- Creates `PricingService` and `BusinessLogicServer`
- Mounts enhanced `/health` endpoint (first-match-wins) then BLS sub-app routes
- Starts HTTP server via `serve({ fetch: app.fetch, port })`
- Logs config on startup (pubkey only, NOT secret key)
- Handles SIGINT/SIGTERM for graceful shutdown

CMD should be: `node dist/entrypoint.js`

### Architecture: Build Configuration
[Source: packages/bls/tsup.config.ts]

```typescript
export default defineConfig({
  entry: ['src/index.ts', 'src/entrypoint.ts'],
  format: ['esm'],
  dts: true,
  sourcemap: true,
  clean: true,
  outDir: 'dist',
});
```

Output: `dist/index.js`, `dist/index.d.ts`, `dist/entrypoint.js`, `dist/entrypoint.d.ts` plus sourcemaps.

### Architecture: Workspace Configuration
[Source: pnpm-workspace.yaml]

```yaml
packages:
  - 'packages/*'
  - 'docker'
```

Building from repo root requires access to `pnpm-workspace.yaml`, `pnpm-lock.yaml`, root `package.json`, and root `tsconfig.json` (extended by BLS's tsconfig).

### Architecture: Existing Docker Reference
[Source: docker/Dockerfile]

The existing Dockerfile pattern for this project:
- Uses `corepack enable && corepack prepare pnpm@latest --activate` for pnpm
- Copies `package.json` files first for layer caching
- Then copies source and builds
- Uses `node -e "fetch(...)"` pattern for health check (Node 20 has native fetch)
- Sets `NODE_ENV=production`

The new BLS Dockerfile should follow a similar pattern but with multi-stage build for smaller final image.

### Architecture: Multi-Stage Docker Build Strategy
[Source: docs/epics/epic-5-standalone-bls-docker.md]

Recommended strategy:
1. **Builder stage** (`node:20-alpine`): Install all deps (including build tools), build TypeScript
2. **Production stage** (`node:20-alpine`): Copy only built artifacts and production `node_modules`

Key optimization points:
- Install build tools (`python3 make g++`) only in builder stage
- Use `--frozen-lockfile` for reproducible installs
- Prune dev dependencies before copying to production stage
- Don't copy `.ts` source files to production stage
- Don't copy test files to production stage

### Architecture: Alpine Node Image
[Source: Docker Hub node:20-alpine]

- `node:20-alpine` is ~50MB base (vs ~200MB for `node:20-slim`)
- Alpine uses musl libc (not glibc) — native addons must be compiled for it
- The `node` user (uid 1000) exists by default in official Node images
- `wget` is available on Alpine by default (no `curl`)
- `apk add --no-cache python3 make g++` installs build dependencies

### Security Considerations
[Source: docs/architecture/14-security.md]

- Run as non-root user (`node`) — never as root in production containers
- Never log private keys or shared secrets
- The entrypoint already masks the secret key (logs pubkey only)
- Container should not include source code, dev dependencies, or build tools in final image

### Scope Boundaries

**In Scope (this story):**
- `packages/bls/Dockerfile` with multi-stage build
- `.dockerignore` file
- Docker image build verification from repo root
- Image size verification (< 150MB)
- Container startup and health check verification
- Non-root user configuration

**Out of Scope:**
- Environment variable documentation (Story 5.3)
- Volume-based storage configuration details (Story 5.4)
- Docker Hub publishing and CI workflow (Story 5.5)
- Docker Compose examples (Story 5.6)
- Kubernetes manifests (Story 5.7)
- BLS contract documentation (Story 5.8)

### Testing

**Test Approach:** Manual verification (no automated unit tests for Dockerfiles — this is infrastructure configuration)

**Test Scenarios:**
1. `docker build -f packages/bls/Dockerfile -t agent-society-bls .` succeeds from repo root
2. `docker images agent-society-bls` shows size < 150MB
3. `docker run` with required env vars starts successfully
4. `curl http://localhost:3100/health` returns healthy JSON with nodeId, pubkey, ilpAddress, timestamp
5. `docker inspect` shows health check passing
6. Container runs as non-root user (`node`)
7. `/data` directory is writable (SQLite db can be created)
8. `docker stop` triggers graceful shutdown (SIGTERM handled)

**Testing Framework:** N/A — manual Docker CLI verification
**Test File Location:** N/A

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-07 | 0.1 | Initial story draft | SM (Claude Opus 4.6) |
| 2026-02-07 | 0.2 | Validation fixes: decisively specify root-level .dockerignore, use proven placeholder package.json pattern for workspace install, add native addon runtime verification step | SM (Claude Opus 4.6) |
| 2026-02-07 | 1.0 | Implementation complete — all tasks verified | Dev (Claude Opus 4.6) |

## Dev Agent Record

### Agent Model Used
Claude Opus 4.6

### File List
| File | Action | Description |
|------|--------|-------------|
| `packages/bls/Dockerfile` | Created | Multi-stage Dockerfile for standalone BLS container |
| `.dockerignore` | Created | Root-level Docker build context exclusions |

### Completion Notes
- Used `pnpm deploy --prod` to create a clean production deployment with only runtime dependencies (no symlinks)
- Initial image was 157MB; optimized to 147MB by stripping `better-sqlite3` build artifacts (`deps/`, `src/`, `binding.gyp`) — SQLite source code (9.5MB) is only needed at compile time
- `libstdc++` is required at runtime on Alpine for the compiled `better-sqlite3` native addon
- `wget` used for health check (Alpine default, no `curl`)
- All 9 acceptance criteria verified via Docker CLI

### Debug Log References
None — no issues encountered during implementation.

## QA Results

### Review Date: 2026-02-07

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

High-quality Dockerfile implementation that follows Docker best practices. The multi-stage build is clean and well-structured with proper layer caching (package files before source), correct use of `pnpm deploy --prod` for symlink-free production deployments, and smart optimization of the better-sqlite3 native addon (stripping build artifacts to reduce image from 157MB to 147MB). The `.dockerignore` correctly excludes unnecessary files from the build context while preserving all workspace root files needed for pnpm resolution.

### Refactoring Performed

None — no refactoring needed. The implementation is clean and follows project conventions.

### Compliance Check

- Coding Standards: ✓ Follows existing project Dockerfile patterns (corepack, frozen-lockfile, placeholder package.json strategy)
- Project Structure: ✓ Dockerfile placed at `packages/bls/Dockerfile`, `.dockerignore` at repo root (correct for Docker build context)
- Testing Strategy: ✓ Manual Docker CLI verification is appropriate for infrastructure configuration
- All ACs Met: ✓ All 9 acceptance criteria verified

### Improvements Checklist

- [x] Multi-stage build correctly separates build tools from production image
- [x] `pnpm deploy --prod` used for clean production deps (no symlinks)
- [x] better-sqlite3 build artifacts stripped for size optimization
- [x] Non-root user with proper `/data` directory ownership
- [x] Health check uses Alpine-native `wget` (not curl)
- [ ] Consider pinning pnpm version instead of `@latest` for reproducible builds (low priority — consistent with existing project pattern)
- [ ] Consider adding `docker/src/` to `.dockerignore` to slightly reduce build context transfer (negligible impact)

### Security Review

No security concerns found. The Dockerfile follows security best practices:
- Runs as non-root `node` user
- No build tools (python3, make, g++) in production stage
- No source `.ts` files in production stage
- `NODE_ENV=production` set
- Secret key handling is in the entrypoint (reviewed and passed in Story 5.1)

### Performance Considerations

No performance concerns. Image size is 147MB (under the 150MB target). Layer caching is well-optimized with package files copied before source code. Health check uses lightweight `wget --spider`.

### Files Modified During Review

None — no files modified.

### Gate Status

Gate: PASS → docs/qa/gates/5.2-bls-docker-image-build-configuration.yml

### Recommended Status

✓ Ready for Done — All 9 acceptance criteria met with clean implementation following project conventions.
