# Story 2.3: Dynamic SPSP Request (Client)

## Status

Done

## Story

**As an** agent developer,
**I want** to request fresh SPSP parameters from a peer,
**so that** I can get a unique payment destination for my specific payment.

## Acceptance Criteria

1. `requestSpspInfo(recipientPubkey: string): Promise<SpspInfo>` method added to `NostrSpspClient`
2. Method generates kind:23194 ephemeral event with NIP-44 encrypted payload
3. Method subscribes for kind:23195 response from recipient
4. Response payload is decrypted and parsed to SpspInfo
5. Method times out after configurable duration (default 10s) with descriptive error
6. Unit tests verify encryption, request/response flow, and timeout handling

## Tasks / Subtasks

- [x] Task 1: Create SpspTimeoutError class (AC: 5)
  - [x] Add `SpspTimeoutError` class to `packages/core/src/errors.ts`
  - [x] Extend `CrosstownError` with code `'SPSP_TIMEOUT'`
  - [x] Constructor accepts `message: string`, `recipientPubkey: string`, and optional `cause?: Error`
  - [x] Export from `packages/core/src/errors.ts`
  - [x] Export from `packages/core/src/index.ts`
  - [x] Add unit tests for new error class

- [x] Task 2: Update NostrSpspClient constructor to accept secret key (AC: 1, 2)
  - [x] Add optional `secretKey?: Uint8Array` parameter to constructor
  - [x] Store secret key as private field
  - [x] Derive pubkey from secret key using `getPublicKey()` from nostr-tools
  - [x] Update existing constructor tests

- [x] Task 3: Create SpspRequest event builder function (AC: 2)
  - [x] Add `buildSpspRequestEvent()` to `packages/core/src/events/builders.ts`
  - [x] Generate unique `requestId` using `crypto.randomUUID()` (Node.js 14.17+)
  - [x] Create `SpspRequest` payload with `requestId` and `timestamp`
  - [x] Encrypt payload using NIP-44 with recipient's pubkey
  - [x] Create kind:23194 event with encrypted content
  - [x] Add `p` tag with recipient pubkey for routing
  - [x] Sign event with sender's secret key
  - [x] Add unit tests for builder function

- [x] Task 4: Create SpspResponse parser function (AC: 4)
  - [x] Add `parseSpspResponse()` to `packages/core/src/events/parsers.ts`
  - [x] Validate event kind is 23195
  - [x] Decrypt content using NIP-44 with sender's secret key
  - [x] Parse JSON to `SpspResponse` interface
  - [x] Validate `requestId`, `destinationAccount`, `sharedSecret` fields
  - [x] Throw `InvalidEventError` for malformed/invalid responses
  - [x] Add unit tests for parser function

- [x] Task 5: Implement requestSpspInfo method (AC: 1, 2, 3, 4, 5)
  - [x] Method signature: `async requestSpspInfo(recipientPubkey: string, options?: { timeout?: number }): Promise<SpspInfo>`
  - [x] Validate secret key is provided (throw SpspError if not)
  - [x] Validate recipientPubkey format using PUBKEY_REGEX
  - [x] Generate requestId and build encrypted kind:23194 event
  - [x] Publish request event to relays using `pool.publish()`
  - [x] Subscribe for kind:23195 response with matching `p` tag (sender pubkey)
  - [x] Set up timeout with configurable duration (default 10s per architecture)
  - [x] On response: decrypt, parse, verify requestId matches, return SpspInfo
  - [x] On timeout: throw `SpspTimeoutError` with descriptive message
  - [x] Clean up subscription on success or timeout

- [x] Task 6: Handle subscription and response matching (AC: 3, 4)
  - [x] Use `pool.subscribeMany()` to subscribe for kind:23195 events
  - [x] Filter subscription to events with `#p` tag containing sender's pubkey
  - [x] Match response `requestId` to sent request `requestId`
  - [x] Handle case where multiple responses arrive (use first matching)
  - [x] Close subscription after receiving valid response or timeout

- [x] Task 7: Implement timeout handling (AC: 5)
  - [x] Create Promise that rejects after timeout duration
  - [x] Use `Promise.race()` between response Promise and timeout
  - [x] Throw `SpspTimeoutError` on timeout (uses code `SPSP_TIMEOUT`)
  - [x] Error message should include timeout duration and recipient pubkey
  - [x] Ensure subscription is closed on timeout

- [x] Task 8: Update module exports (AC: 1)
  - [x] Export `buildSpspRequestEvent` from `packages/core/src/events/index.ts`
  - [x] Export `parseSpspResponse` from `packages/core/src/events/index.ts`
  - [x] Export `SpspTimeoutError` from `packages/core/src/index.ts`

- [x] Task 9: Write unit tests for requestSpspInfo happy path (AC: 1, 2, 3, 4, 6)
  - [x] Test method exists and has correct signature
  - [x] Test publishes kind:23194 event to relays
  - [x] Test event content is NIP-44 encrypted
  - [x] Test subscribes for kind:23195 response
  - [x] Test decrypts and parses valid response
  - [x] Test returns SpspInfo with correct fields

- [x] Task 10: Write unit tests for encryption/decryption (AC: 2, 4, 6)
  - [x] Test request payload is encrypted with recipient pubkey
  - [x] Test response is decrypted with sender secret key
  - [x] Test round-trip encryption/decryption works correctly
  - [x] Test malformed encrypted content throws error

- [x] Task 11: Write unit tests for timeout handling (AC: 5, 6)
  - [x] Test times out after default 10s if no response
  - [x] Test custom timeout duration is respected
  - [x] Test throws `SpspTimeoutError` with `SPSP_TIMEOUT` code
  - [x] Test subscription is cleaned up on timeout
  - [x] Test error message includes recipient pubkey

- [x] Task 12: Write unit tests for error handling (AC: 6)
  - [x] Test throws SpspError if secret key not provided
  - [x] Test throws SpspError for invalid recipientPubkey format
  - [x] Test throws SpspError if relay publish fails
  - [x] Test handles InvalidEventError from parser gracefully
  - [x] Test handles mismatched requestId (ignores response)

## Dev Notes

### Previous Story Insights
[Source: docs/stories/2.2.story.md#dev-agent-record]

From Story 2.2 (Static SPSP Info Publishing):
- Package uses ESM (`"type": "module"`) - use `.js` extension in imports
- TypeScript strict mode is enabled
- 129 tests currently pass in core package
- Test helpers cast through `unknown` for `VerifiedEvent` type: `as unknown as VerifiedEvent`
- `NostrSpspClient` class provides established pattern for constructor and SimplePool usage
- `NostrSpspServer` class shows pattern for accepting secretKey and using pool.publish()
- `buildSpspInfoEvent()` function demonstrates event building and signing pattern
- `Promise.any()` pattern used for relay confirmation
- PUBKEY_REGEX pattern duplicated locally - continue using this pattern

### Project Structure
[Source: docs/architecture/9-source-tree.md]

Files to create/modify for this story:
```
packages/core/src/
├── spsp/
│   ├── NostrSpspClient.ts              # Add requestSpspInfo method (modify)
│   └── NostrSpspClient.test.ts         # Add new tests (modify)
├── events/
│   ├── builders.ts                     # Add buildSpspRequestEvent (modify)
│   ├── builders.test.ts                # Add builder tests (modify)
│   ├── parsers.ts                      # Add parseSpspResponse (modify)
│   ├── parsers.test.ts                 # Add parser tests (modify)
│   └── index.ts                        # Add exports (modify)
├── errors.ts                           # Add SpspTimeoutError class (modify)
├── errors.test.ts                      # Add SpspTimeoutError tests (modify/create)
├── index.ts                            # Export SpspTimeoutError (modify)
└── types.ts                            # SpspRequest, SpspResponse already exist
```

### Data Models
[Source: docs/architecture/4-data-models.md#43-spsprequest, #44-spspresponse]

**SpspRequest (kind:23194):**
```typescript
export interface SpspRequest {
  /** Unique request identifier for correlation */
  requestId: string;
  /** Unix timestamp of the request */
  timestamp: number;
}
```

**SpspResponse (kind:23195):**
```typescript
export interface SpspResponse {
  /** Matching request identifier */
  requestId: string;
  /** ILP address to send payment to */
  destinationAccount: string;
  /** Base64-encoded shared secret for STREAM protocol */
  sharedSecret: string;
}
```

Both interfaces already exist in `packages/core/src/types.ts` [Source: packages/core/src/types.ts:33-55]

### Event Kind Constants
[Source: packages/core/src/constants.ts]

Constants already exist:
```typescript
export const SPSP_REQUEST_KIND = 23194;
export const SPSP_RESPONSE_KIND = 23195;
```

### NIP-44 Encryption with nostr-tools
[Source: docs/architecture/3-tech-stack.md, nostr-tools documentation]

**nostr-tools provides NIP-44 encryption via `nip44` module:**
```typescript
import { nip44 } from 'nostr-tools';
import { getPublicKey } from 'nostr-tools/pure';

// Get conversation key for encryption/decryption
const conversationKey = nip44.getConversationKey(secretKey, recipientPubkey);

// Encrypt payload
const encrypted = nip44.encrypt(JSON.stringify(payload), conversationKey);

// Decrypt payload
const decrypted = nip44.decrypt(encryptedContent, conversationKey);
const payload = JSON.parse(decrypted);
```

**Note:** NIP-44 uses XChaCha20-Poly1305 encryption with a shared secret derived from ECDH between sender and recipient keys.

**Deriving public key from secret key:**
```typescript
import { getPublicKey } from 'nostr-tools/pure';

const pubkey = getPublicKey(secretKey); // Returns hex string
```

### Dynamic SPSP Handshake Flow
[Source: docs/architecture/7-core-workflows.md#72-dynamic-spsp-handshake]

```
1. Sender calls requestSpspInfo(recipientPubkey)
2. Client generates unique requestId
3. Client encrypts SpspRequest payload with NIP-44
4. Client publishes kind:23194 event with encrypted content
5. Client subscribes for kind:23195 events from recipient
6. [Recipient receives, processes, responds - Story 2.4]
7. Client receives kind:23195 event
8. Client decrypts response using NIP-44
9. Client verifies requestId matches
10. Client returns SpspInfo to caller
```

### Event Structure for SPSP Request (kind:23194)
[Source: NIP-04/NIP-44 patterns, docs/architecture/4-data-models.md]

```typescript
const event = {
  kind: 23194,               // SPSP_REQUEST_KIND
  content: encrypted,         // NIP-44 encrypted SpspRequest JSON
  tags: [
    ['p', recipientPubkey],  // Tag recipient for routing/filtering
  ],
  created_at: Math.floor(Date.now() / 1000),
  // pubkey and sig added by finalizeEvent()
};
```

### Event Structure for SPSP Response (kind:23195)
[Source: NIP-04/NIP-44 patterns, docs/architecture/4-data-models.md]

```typescript
const event = {
  kind: 23195,               // SPSP_RESPONSE_KIND
  content: encrypted,         // NIP-44 encrypted SpspResponse JSON
  tags: [
    ['p', senderPubkey],     // Tag original requester
    ['e', requestEventId],   // Reference original request (optional)
  ],
  created_at: Math.floor(Date.now() / 1000),
};
```

### nostr-tools SimplePool Subscription API
[Source: packages/core/src/discovery/NostrPeerDiscovery.ts]

**SimplePool.subscribeMany() for subscriptions:**
```typescript
import { SimplePool, type SubCloser } from 'nostr-tools/pool';
import type { Filter } from 'nostr-tools/filter';

const filter: Filter = {
  kinds: [SPSP_RESPONSE_KIND],
  '#p': [myPubkey],          // Events tagged with my pubkey
  since: Math.floor(Date.now() / 1000) - 5, // Recent events only
};

const sub = pool.subscribeMany(relayUrls, [filter], {
  onevent(event) {
    // Handle incoming event
  },
  oneose() {
    // End of stored events
  },
});

// Later: close subscription
sub.close();
```

### Error Handling
[Source: docs/architecture/11-error-handling-strategy.md]

**SpspTimeoutError class (to be created in Task 1):**
```typescript
/**
 * Error thrown when an SPSP request times out waiting for a response.
 */
export class SpspTimeoutError extends CrosstownError {
  public readonly recipientPubkey: string;

  constructor(message: string, recipientPubkey: string, cause?: Error) {
    super(message, 'SPSP_TIMEOUT', cause);
    this.name = 'SpspTimeoutError';
    this.recipientPubkey = recipientPubkey;
  }
}
```

**Error scenarios for requestSpspInfo:**
- Secret key not provided → throw `SpspError` with descriptive message
- Invalid recipientPubkey format → throw `SpspError`
- Relay publish fails → throw `SpspError` with cause
- Timeout waiting for response → throw `SpspTimeoutError` with code `SPSP_TIMEOUT`
- Decryption fails → throw `SpspError` with cause
- Invalid response format → ignore response, continue waiting

**Timeout Configuration:**
- Default: 10 seconds per architecture docs
- Configurable via optional parameter

```typescript
// Timeout pattern
const timeoutPromise = new Promise<never>((_, reject) =>
  setTimeout(() => reject(new SpspTimeoutError(
    `SPSP request timed out after ${timeout}ms waiting for response`,
    recipientPubkey
  )), timeout)
);

const result = await Promise.race([responsePromise, timeoutPromise]);
```

### Coding Standards
[Source: docs/architecture/12-coding-standards.md]

| Element | Convention | Example |
|---------|------------|---------|
| Files | PascalCase for class files | `NostrSpspClient.ts` |
| Classes | PascalCase | `NostrSpspClient` |
| Methods | camelCase | `requestSpspInfo` |
| Constants | UPPER_SNAKE_CASE | `SPSP_REQUEST_KIND` |

**Critical Rules:**
- Never use `any` - use `unknown` and type guards
- Always mock SimplePool in tests - no live relay dependencies
- Export from index.ts - all public APIs exported from package index
- Use nostr-tools types - don't redefine event types
- NEVER log private keys or shared secrets

### Testing
[Source: docs/architecture/13-test-strategy-and-standards.md]

**Framework:** Vitest 1.x

**Testing SpspTimeoutError:**
```typescript
import { describe, it, expect } from 'vitest';
import { SpspTimeoutError, CrosstownError } from './errors.js';

describe('SpspTimeoutError', () => {
  it('should have correct error code', () => {
    const error = new SpspTimeoutError('timeout', 'abc123');
    expect(error.code).toBe('SPSP_TIMEOUT');
  });

  it('should store recipientPubkey', () => {
    const error = new SpspTimeoutError('timeout', 'abc123');
    expect(error.recipientPubkey).toBe('abc123');
  });

  it('should extend CrosstownError', () => {
    const error = new SpspTimeoutError('timeout', 'abc123');
    expect(error).toBeInstanceOf(CrosstownError);
  });
});
```

**Mocking NIP-44:**
```typescript
import { vi } from 'vitest';

// Mock nip44 module
vi.mock('nostr-tools', async () => {
  const actual = await vi.importActual('nostr-tools');
  return {
    ...actual,
    nip44: {
      getConversationKey: vi.fn().mockReturnValue(new Uint8Array(32)),
      encrypt: vi.fn().mockReturnValue('mock-encrypted-content'),
      decrypt: vi.fn().mockReturnValue('{"requestId":"test","destinationAccount":"g.test","sharedSecret":"c2VjcmV0"}'),
    },
  };
});
```

**Mocking pool.subscribeMany():**
```typescript
const mockSub = { close: vi.fn() };
vi.mocked(mockPool.subscribeMany).mockReturnValue(mockSub);

// Simulate incoming event
vi.mocked(mockPool.subscribeMany).mockImplementation((_, __, callbacks) => {
  setTimeout(() => {
    callbacks.onevent?.(mockResponseEvent);
  }, 10);
  return mockSub;
});
```

**Test Requirements:**
- Follow AAA pattern (Arrange, Act, Assert)
- Mock all SimplePool and nip44 calls
- Test success, timeout, and error paths
- >80% coverage for new functionality
- Test encryption/decryption round-trip

### Security Considerations
[Source: docs/architecture/14-security.md]

- Use NIP-44 encryption for SPSP request/response (AC: 2, 4)
- NEVER log private keys or shared secrets
- Validate event signatures before decryption
- Handle decryption failures gracefully (don't expose details)

## Dev Agent Record

### Agent Model Used
Claude Opus 4.5

### File List
**New Files:**
- `packages/core/src/errors.test.ts` - Unit tests for error classes including SpspTimeoutError

**Modified Files:**
- `packages/core/src/errors.ts` - Added SpspTimeoutError class
- `packages/core/src/index.ts` - Added exports for SpspTimeoutError, buildSpspRequestEvent, parseSpspResponse
- `packages/core/src/events/index.ts` - Added exports for buildSpspRequestEvent, parseSpspResponse
- `packages/core/src/events/builders.ts` - Added buildSpspRequestEvent function with NIP-44 encryption
- `packages/core/src/events/builders.test.ts` - Added tests for buildSpspRequestEvent
- `packages/core/src/events/parsers.ts` - Added parseSpspResponse function with NIP-44 decryption
- `packages/core/src/events/parsers.test.ts` - Added tests for parseSpspResponse
- `packages/core/src/spsp/NostrSpspClient.ts` - Added secretKey to constructor, implemented requestSpspInfo method; fixed subscribeMany call to pass filter directly (not wrapped in array)
- `packages/core/src/spsp/NostrSpspClient.test.ts` - Added comprehensive tests for requestSpspInfo; added Filter import and fixed type assertion
- `packages/core/src/spsp/NostrSpspServer.test.ts` - Fixed index signature property access using bracket notation

### Debug Log References
```
$ npx tsc --noEmit
# Before fixes: 4 TypeScript compilation errors
# After fixes: 0 errors

$ npx vitest run
# 180 tests passing across 9 test files

$ pnpm lint
# 0 lint errors
```

### Completion Notes
- Implemented dynamic SPSP request/response flow using NIP-44 encryption
- All 180 tests pass (up from 129 in Story 2.2)
- Used `crypto.randomUUID()` for request ID generation (Node.js 14.17+)
- Timeout handling uses Promise race pattern with configurable duration (default 10s)
- Response matching validates requestId to handle multiple concurrent requests
- **QA Fix Round 1:** Fixed 4 TypeScript compilation errors:
  1. `NostrSpspClient.ts:165` - Changed `[filter]` to `filter` for subscribeMany call to match API type signature
  2. `NostrSpspClient.test.ts:488` - Added Filter import and fixed type assertion for filter access
  3. `NostrSpspServer.test.ts:152,170` - Changed dot notation to bracket notation for index signature property access

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-06 | 0.1 | Initial story draft | SM |
| 2026-02-06 | 0.2 | Added Task 1 for SpspTimeoutError class, renumbered tasks, clarified crypto.randomUUID() usage, updated error handling patterns | SM |
| 2026-02-06 | 1.0 | Implementation complete - All tasks done, 180 tests passing | Dev |
| 2026-02-06 | 1.1 | Applied QA fixes - Fixed 4 TypeScript compilation errors (TS-001, TS-002, TS-003) | Dev |

## QA Results

### Review Date: 2026-02-06

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

The implementation is well-structured and follows established patterns from the codebase. The code demonstrates good separation of concerns with event builders/parsers separate from the client logic. NIP-44 encryption is implemented correctly using nostr-tools. The Promise-based timeout pattern with `Promise.race()` is idiomatic. Error handling is comprehensive with appropriate error types for different failure modes.

**Strengths:**
- Clean separation: builders.ts, parsers.ts, NostrSpspClient.ts each have focused responsibilities
- Consistent patterns: follows existing codebase conventions (e.g., PUBKEY_REGEX validation, error wrapping)
- Comprehensive test coverage: 41 new tests for NostrSpspClient, 28 tests for parsers, 17 tests for builders
- Security: NIP-44 encryption properly implemented, secrets not logged, input validation present

**Areas Requiring Attention:**
- TypeScript compilation errors found (see below)

### Refactoring Performed

No refactoring performed. Issues identified require developer attention due to potential API design decisions.

### Compliance Check

- Coding Standards: Partial - TypeScript strict mode violations found (4 errors)
- Project Structure: Pass - Files in correct locations per source-tree.md
- Testing Strategy: Pass - 180 tests pass, SimplePool mocked, AAA pattern followed
- All ACs Met: Pass - All 6 acceptance criteria implemented and tested

### Improvements Checklist

- [ ] **CRITICAL**: Fix TypeScript compilation errors (4 errors found)
  - `NostrSpspClient.ts:165` - `subscribeMany` called with `[filter]` but type expects `Filter` not `Filter[]`
  - `NostrSpspClient.test.ts:488` - Array indexing issue with Filter type assertion
  - `NostrSpspServer.test.ts:152,170` - Index signature property access (use bracket notation)
- [ ] Consider adding explicit type annotation for the filter variable in requestSpspInfo

### Security Review

- NIP-44 encryption correctly implemented for request/response payloads
- Private keys handled as parameters, not stored persistently
- No logging of secrets or decrypted content in implementation
- Input validation present for pubkey format

**No security concerns found.**

### Performance Considerations

- Subscription cleanup on timeout/success prevents resource leaks
- Promise.any() used for relay publishing provides fail-fast behavior
- `since` filter prevents processing old events

**No performance concerns found.**

### Files Modified During Review

None - TypeScript errors identified require dev to fix.

### Gate Status

Gate: CONCERNS -> docs/qa/gates/2.3-dynamic-spsp-request-client.yml

### Recommended Status

Changes Required - TypeScript compilation errors must be fixed before the code can be considered production-ready. The errors indicate type mismatches that could cause runtime issues or IDE problems for library consumers.

---

### Review Date: 2026-02-06 (Re-review)

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Re-review following developer fixes.** All previously identified TypeScript compilation errors have been resolved. The implementation now passes all quality gates.

**Verification Results:**
- TypeScript: 0 errors (previously 4)
- Tests: 180 passing
- Lint: 0 errors

**Code Review Highlights:**

1. **SpspTimeoutError** (`errors.ts:55-63`): Well-implemented error class extending CrosstownError with proper error code `SPSP_TIMEOUT` and recipientPubkey storage for debugging context.

2. **buildSpspRequestEvent** (`builders.ts:72-99`): Clean implementation using crypto.randomUUID() for request ID, NIP-44 encryption with proper conversation key derivation, and correct event structure with `p` tag for recipient routing.

3. **parseSpspResponse** (`parsers.ts:136-193`): Robust parsing with proper error handling for decryption failures, JSON parsing, and field validation. Uses type guards appropriately.

4. **requestSpspInfo** (`NostrSpspClient.ts:115-213`): Excellent implementation of the dynamic SPSP handshake:
   - Proper validation of secret key presence and pubkey format
   - Correct use of Promise-based subscription with timeout
   - Clean subscription cleanup on both success and timeout
   - Response matching via requestId prevents cross-talk between concurrent requests

### Refactoring Performed

None required - code is clean and well-structured.

### Compliance Check

- Coding Standards: ✓ TypeScript strict mode, no `any` usage, proper error handling
- Project Structure: ✓ Files in correct locations per architecture docs
- Testing Strategy: ✓ 180 tests, SimplePool mocked, AAA pattern, comprehensive coverage
- All ACs Met: ✓ All 6 acceptance criteria fully implemented and tested

### Improvements Checklist

- [x] TypeScript compilation errors fixed (TS-001, TS-002, TS-003)
- [x] All tests passing
- [x] Lint passing

### Security Review

- NIP-44 encryption correctly implemented for request/response payloads
- Private keys handled as parameters, not stored persistently
- No logging of secrets or decrypted content in implementation
- Input validation present for pubkey format
- Empty catch block at line 192 is intentional (invalid responses are silently ignored to continue waiting for valid response)

**No security concerns.**

### Performance Considerations

- Subscription cleanup on timeout/success prevents resource leaks
- Promise.any() used for relay publishing provides fail-fast behavior
- `since` filter prevents processing old events
- Timeout uses standard setTimeout pattern, properly cleared on success

**No performance concerns.**

### Files Modified During Review

None.

### Gate Status

Gate: PASS -> docs/qa/gates/2.3-dynamic-spsp-request-client.yml

### Recommended Status

✓ Ready for Done - All acceptance criteria met, all tests passing, no compilation errors, code follows established patterns and best practices.
