# Story 5.5: Docker Hub Publishing

## Status

Done
## Story

**As a** DevOps engineer,
**I want** the BLS image published to Docker Hub,
**so that** agent-runtime can pull it without building locally.

## Acceptance Criteria

1. GitHub Actions workflow: `.github/workflows/publish-bls.yml`
2. Workflow triggers on:
   - Push to `main` with changes in `packages/bls/`
   - Manual dispatch with version input
   - Git tags matching `bls-v*`
3. Image published to Docker Hub: `di3twater/crosstown-bls`
4. Docker Hub credentials stored as GitHub secrets (`DOCKERHUB_USERNAME`, `DOCKERHUB_TOKEN`)
5. Image tagged with:
   - `latest` (main branch)
   - `vX.Y.Z` (semantic version from tag)
   - Git SHA for traceability
6. Multi-architecture build: `linux/amd64`, `linux/arm64`
7. Workflow includes vulnerability scan (e.g., Trivy)
8. README includes pull command: `docker pull di3twater/crosstown-bls:latest`

## Tasks / Subtasks

- [x] Task 1: Create GitHub Actions workflow file (AC: 1, 2, 3, 4, 5, 6, 7)
  - [x] Create `.github/workflows/publish-bls.yml`
  - [x] Configure three trigger conditions:
    - `push` to `main` with path filter `packages/bls/**`
    - `workflow_dispatch` with `version` string input (optional, for manual tagging)
    - `push` tags matching `bls-v*`
  - [x] Add `concurrency` configuration at workflow level to cancel in-flight builds when a new push arrives:
    - `group: ${{ github.workflow }}-${{ github.ref }}`
    - `cancel-in-progress: true`
  - [x] Add job `build-and-push` running on `ubuntu-latest`
  - [x] Step 1: Checkout repository with `actions/checkout@v4`
  - [x] Step 2: Set up QEMU for multi-arch with `docker/setup-qemu-action@v3`
  - [x] Step 3: Set up Docker Buildx with `docker/setup-buildx-action@v3`
  - [x] Step 4: Log in to Docker Hub with `docker/login-action@v3` using secrets `DOCKERHUB_USERNAME` and `DOCKERHUB_TOKEN`
  - [x] Step 5: Extract metadata (tags, labels) with `docker/metadata-action@v5`:
    - For push to `main`: tag as `latest`
    - For `bls-v*` tags: extract semver (e.g., `bls-v1.2.3` -> `1.2.3`)
    - Always include Git SHA tag (`sha-<short>`)
    - For `workflow_dispatch`: use the provided version input
  - [x] Step 6: Build and push multi-arch image with `docker/build-push-action@v6`:
    - `context: .` (repo root — Dockerfile uses `COPY` from root)
    - `file: packages/bls/Dockerfile`
    - `platforms: linux/amd64,linux/arm64`
    - `push: true`
    - `tags` and `labels` from metadata step
    - Enable build cache with `cache-from` / `cache-to` using GitHub Actions cache
  - [x] Step 7: Run Trivy vulnerability scan with `aquasecurity/trivy-action@0.33.0`:
    - `image-ref`: use the image reference from the push step
    - `severity: CRITICAL,HIGH`
    - `exit-code: 1` (fail workflow on critical/high vulnerabilities)
    - Configure `format: table` for readable output
  - [x] Step 8: Generate SBOM with Trivy (supply chain transparency):
    - Use `aquasecurity/trivy-action@0.33.0` with `format: cyclonedx`
    - Upload SBOM as a workflow artifact via `actions/upload-artifact@v4`
    - This provides a Software Bill of Materials for downstream consumers

- [x] Task 2: Validate workflow YAML syntax and structure (AC: 1)
  - [x] Ensure YAML is syntactically valid (proper indentation, quoting)
  - [x] Verify all action references use pinned major versions (e.g., `@v4`, `@v3`)
  - [x] Confirm secret names match expected GitHub secrets (`DOCKERHUB_USERNAME`, `DOCKERHUB_TOKEN`)
  - [x] Verify `workflow_dispatch` inputs are correctly defined

- [x] Task 3: Update BLS README with pull command (AC: 8)
  - [x] Add Docker Hub pull command to README Quick Start section:
    ```
    docker pull di3twater/crosstown-bls:latest
    ```
  - [x] Update the existing `docker run` example to use the Docker Hub image name `di3twater/crosstown-bls`
  - [x] Add a "Published Images" or "Docker Hub" section documenting available tags (`latest`, `vX.Y.Z`, `sha-<short>`)

- [x] Task 4: Document and validate tagging logic (AC: 5)
  - [x] Add YAML comments in the workflow documenting expected tag outputs for each trigger scenario:
    - Push to `main` with `packages/bls/` change -> `latest`, `sha-abc1234`
    - Tag `bls-v1.2.3` -> `1.2.3`, `sha-abc1234`
    - Manual dispatch with version `2.0.0` -> `2.0.0`, `sha-abc1234`
  - [x] Add a `dry-run` job or conditional `push: ${{ github.event_name != 'pull_request' }}` for PR validation
  - [x] Note: No TypeScript unit tests — workflow YAML is validated through syntax checks and dry-run triggers

- [x] Task 5: Verify Dockerfile builds correctly for multi-arch (AC: 6)
  - [x] Confirm existing `packages/bls/Dockerfile` uses `node:20-alpine` (supports both amd64 and arm64)
  - [x] Confirm `better-sqlite3` native addon compiles on arm64 alpine (uses `python3 make g++` in builder stage — already configured)
  - [x] Confirm no architecture-specific assumptions in the Dockerfile
  - [x] Note: `apk add --no-cache python3 make g++` in builder stage handles native compilation for both architectures

- [x] Task 6: Verify end-to-end workflow correctness (AC: 1-8)
  - [x] Review complete workflow file for logical correctness
  - [x] Ensure Trivy scan runs AFTER the image is pushed (scans the pushed image)
  - [x] Ensure SBOM generation runs after the scan step and artifact is uploaded
  - [x] Ensure build cache is properly configured to speed up subsequent builds
  - [x] Verify `concurrency` group cancels duplicate runs on the same ref
  - [x] Confirm the workflow does NOT run on PRs (only push to main, tags, and manual dispatch)

## Dev Notes

### Previous Story Insights
[Source: docs/stories/5.4.story.md#dev-agent-record]

From Story 5.4 implementation:
- 771 tests passing after Story 5.4
- `createEventStore` helper with directory-check and fallback was added
- No issues encountered during 5.4 implementation
- All BLS package code is in `packages/bls/`

From Story 5.2 implementation:
[Source: docs/stories/5.2.story.md — referenced in 5.4 dev notes]
- Dockerfile is at `packages/bls/Dockerfile`
- Build command: `docker build -f packages/bls/Dockerfile -t crosstown-bls .` (builds from repo root)
- Image is 147MB (under the 150MB target)
- Base image: `node:20-alpine`
- Multi-stage build: builder stage compiles `better-sqlite3` native addon, production stage is minimal
- `better-sqlite3` requires `python3 make g++` in builder and `libstdc++` in production
- Runs as non-root `node` user

### Dockerfile Context
[Source: packages/bls/Dockerfile]

Key details for CI workflow:
- Build context must be the repo root (`.`) because Dockerfile copies workspace root files (`package.json`, `pnpm-workspace.yaml`, `pnpm-lock.yaml`)
- Dockerfile path: `packages/bls/Dockerfile`
- The build installs pnpm via `corepack`, runs `pnpm install --frozen-lockfile`, builds with `tsup`, then uses `pnpm deploy --prod` for minimal production output
- Native dependencies (`better-sqlite3`) compile from source in the builder stage — this works on both `amd64` and `arm64` Alpine targets since `python3`, `make`, and `g++` are installed

### Docker Hub Configuration
[Source: docs/epics/epic-5-standalone-bls-docker.md#configuration]

| Setting | Value |
|---------|-------|
| Docker Hub Organization | `di3twater` |
| Image Name | `crosstown-bls` |
| Full Image Reference | `di3twater/crosstown-bls` |

### GitHub Actions Patterns
[Source: docs/architecture/10-infrastructure-and-deployment.md]

- CI/CD Platform: GitHub Actions
- Existing pipeline location: `.github/workflows/ci.yml` (does not currently exist — this will be the first workflow file)
- Publishing flow: Version bump -> git tag -> GitHub Actions builds and tests -> publish

### .dockerignore
[Source: .dockerignore]

```
node_modules/
dist/
*.test.ts
.git/
*.md
packages/core/src/
packages/relay/src/
packages/examples/
docs/
.github/
```

The `.dockerignore` excludes `.github/` so CI workflow files won't bloat the Docker build context.

### BLS Package Configuration
[Source: packages/bls/package.json]

```json
{
  "name": "@crosstown/bls",
  "version": "0.1.0",
  "scripts": {
    "build": "tsup"
  }
}
```

Current version is `0.1.0`. Tags will follow the pattern `bls-v0.1.0`, `bls-v1.0.0`, etc.

### Existing README Structure
[Source: packages/bls/README.md]

The README already has:
- Quick Start section with `docker run` example (currently using `crosstown/bls` — needs update to `di3twater/crosstown-bls`)
- Environment Variables table
- Endpoints documentation

Changes needed: Update image name in Quick Start from `crosstown/bls` to `di3twater/crosstown-bls`, add `docker pull` command, add available tags documentation.

### GitHub Actions Docker Workflow Pattern
[Source: No specific guidance found in architecture docs]

Standard pattern for Docker Hub publishing with GitHub Actions uses these actions:
- `actions/checkout@v4` — checkout repository
- `docker/setup-qemu-action@v3` — enable multi-arch builds
- `docker/setup-buildx-action@v3` — enable Buildx for multi-platform
- `docker/login-action@v3` — authenticate with Docker Hub
- `docker/metadata-action@v5` — compute image tags from git context
- `docker/build-push-action@v6` — build and push multi-arch image
- `aquasecurity/trivy-action@0.33.0` — vulnerability scanning (pinned version; do NOT use `@master`)

### Workflow Concurrency
[Source: GitHub Actions documentation — concurrency groups]

Use `concurrency` at the workflow level to avoid redundant builds. When a new push arrives on the same branch/tag while a build is running, the in-progress run is cancelled:

```yaml
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true
```

This reduces CI resource usage and avoids publishing stale images from superseded commits.

### SBOM Generation
[Source: Supply chain security best practices]

A Software Bill of Materials (SBOM) provides transparency into the image contents. Trivy can generate an SBOM in CycloneDX format alongside the vulnerability scan. The SBOM is uploaded as a workflow artifact for downstream consumers or compliance audits. This is a low-effort addition since Trivy is already configured for scanning.

### Security Considerations
[Source: GitHub Actions secrets best practices — no project-specific architecture doc covers Docker Hub secrets]

- Docker Hub credentials (`DOCKERHUB_USERNAME`, `DOCKERHUB_TOKEN`) must be stored as GitHub repository secrets
- Never log credentials — GitHub Actions masks secrets automatically
- The workflow should NOT expose any secret values in logs

### Scope Boundaries

**In Scope (this story):**
- `.github/workflows/publish-bls.yml` — new GitHub Actions workflow file
- `packages/bls/README.md` — update with Docker Hub pull command and image name

**Out of Scope:**
- Docker Compose examples (Story 5.6)
- Kubernetes manifests (Story 5.7)
- BLS contract documentation (Story 5.8)
- Modifying the Dockerfile (complete in Story 5.2)
- Setting up Docker Hub repository or secrets (manual admin task — documented as prerequisite)
- CI test workflow (separate concern — this workflow is specifically for Docker image publishing)

### Testing

**Test Approach:** This story is primarily infrastructure/CI configuration. There is no runtime application code to unit test. Validation is done through:

1. **YAML syntax validation** — Ensure the workflow file is valid YAML
2. **Workflow logic review** — Manual review of trigger conditions, tag extraction, and push logic
3. **Dry-run validation** — The workflow can be tested by:
   - Creating a PR to verify it does NOT trigger on PRs
   - Merging to `main` with a `packages/bls/` change to verify `latest` tag
   - Pushing a `bls-v*` tag to verify semver extraction
4. **Trivy scan** — Validates that the pushed image has no critical/high vulnerabilities

**Test Standards:**
[Source: docs/architecture/13-test-strategy-and-standards.md]
- Framework: Vitest 1.x (but not applicable for YAML workflow files)
- CI integration: GitHub Actions runs `pnpm test` on all PRs (existing test suite continues to pass)
- No new unit tests needed for this story (workflow YAML is not executable TypeScript)

## File List

| File | Action | Description |
|------|--------|-------------|
| `.github/workflows/publish-bls.yml` | Created | GitHub Actions workflow for Docker Hub publishing |
| `packages/bls/README.md` | Modified | Added pull command, Docker Hub section, updated image name |

## Dev Agent Record

### Agent Model Used
Claude Opus 4.6

### Debug Log References
No issues encountered.

### Completion Notes
- Created GitHub Actions workflow with 3 trigger conditions (push to main with path filter, bls-v* tags, manual dispatch)
- Multi-arch build for linux/amd64 and linux/arm64 using QEMU + Buildx
- Image tags: `latest` (main), semver from `bls-v*` tags, `sha-<short>` for traceability, manual version input
- Trivy vulnerability scan (CRITICAL,HIGH, exit-code 1) + SBOM generation (CycloneDX) uploaded as artifact
- Build cache via GitHub Actions cache (type=gha)
- Concurrency group cancels in-flight builds on same ref
- PR guard: `push: ${{ github.event_name != 'pull_request' }}`
- Updated README with `docker pull` command, corrected image name to `di3twater/crosstown-bls`, added Docker Hub tags documentation
- Dockerfile verified for multi-arch: node:20-alpine, python3/make/g++ for native compilation, no arch-specific assumptions
- 771 tests passing, 0 failures — no regressions

## QA Results

### Review Date: 2026-02-07 (R2)

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall: Strong implementation.** The workflow is well-structured, follows GitHub Actions best practices, and meets all 8 acceptance criteria. The metadata-action tag logic correctly maps all three trigger scenarios. The README updates are accurate and complete. No runtime code changes means no regression risk to the existing 771-test suite (all passing, verified independently).

**Key Strengths:**
- Clean separation of concerns across 8 well-commented steps with header doc explaining expected tag outputs per trigger
- Correct use of `docker/metadata-action@v5` tag patterns — verified for all 3 trigger scenarios plus edge case (manual dispatch without version)
- Build cache (`type=gha,mode=max`) for CI performance
- Concurrency group cancels redundant builds on same ref
- SBOM generation for supply chain transparency (beyond AC requirements)
- PR guard via `push: ${{ github.event_name != 'pull_request' }}` — defensive best practice
- Least-privilege permissions (`contents: read`)

### Findings

**FIND-01 (Info): `on.push.tags` coexisting with `on.push.branches`+`paths` — VERIFIED CORRECT**
Tag pushes bypass `branches` and `paths` filters. This is documented GitHub Actions behavior. No issue.

**FIND-02 (Info): Trivy action pinned to `@0.33.0`**
Good practice pinning to a specific version rather than `@master`. Reproducible builds.

**FIND-03 (Info): `exit-code: "1"` as string**
The Trivy action accepts this as a string. Correctly quoted. No issue.

**FIND-04 (Low): Trivy scans only `amd64` variant of multi-arch manifest**
`image-ref` references the manifest list digest. Trivy defaults to the runner's platform (`linux/amd64`). The `arm64` variant is not scanned. In practice both share the same Alpine base and layers, so vulnerability profiles should be identical. Known limitation — acceptable at this maturity level.

**FIND-05 (Info): `inputs.version` undefined on non-dispatch triggers**
`${{ inputs.version }}` resolves to `''` when inputs context is unavailable. `enable=${{ inputs.version != '' }}` correctly evaluates to `false`. No spurious tags produced. Verified correct.

**FIND-06 (Medium): SBOM generation skipped when Trivy scan fails**
If the vulnerability scan (Step 7) exits with code 1, Steps 8-9 (SBOM generation + upload) are never reached. The SBOM would arguably be most useful when vulnerabilities are found, for forensic/audit purposes. Adding `if: always()` to the SBOM steps would ensure they run regardless of scan outcome. **Not blocking — future improvement.**

**FIND-07 (Low): Scan is post-push, not a true gate**
The image is pushed to Docker Hub in Step 6 before the Trivy scan in Step 7. A vulnerable image briefly exists on Docker Hub before the workflow fails. This is a known limitation of multi-arch Docker CI pipelines (local `--load` doesn't support multi-platform). Acceptable trade-off.

**FIND-08 (Low): Permissive tag extraction pattern**
`type=match,pattern=bls-v(.*),group=1` would match non-semver strings (e.g., `bls-vfoo` → tag `foo`). A stricter pattern like `bls-v(\d+\.\d+\.\d+)` would enforce semver. Low risk since tag naming is under project control.

### Refactoring Performed

None. No code changes warranted — this is a clean infrastructure story with no runtime code.

### Compliance Check

- Coding Standards: ✓ N/A for YAML workflow files; README follows existing markdown conventions
- Project Structure: ✓ Workflow placed at `.github/workflows/publish-bls.yml` per architecture doc §10.2
- Testing Strategy: ✓ No unit tests required for YAML workflow files; validation done through YAML syntax check (yaml.safe_load PASSED) + logic review + dry-run triggers
- All ACs Met: ✓ See AC traceability below

### AC Traceability

| AC | Requirement | Status | Evidence |
|----|------------|--------|----------|
| 1 | GitHub Actions workflow at `.github/workflows/publish-bls.yml` | ✓ | File exists, valid YAML (syntax validated) |
| 2 | Three trigger conditions (push to main + paths, manual dispatch, bls-v* tags) | ✓ | Workflow lines 10-22 |
| 3 | Image published to `di3twater/crosstown-bls` | ✓ | `env.IMAGE_NAME` line 29 |
| 4 | Docker Hub credentials as GitHub secrets | ✓ | `secrets.DOCKERHUB_USERNAME`/`DOCKERHUB_TOKEN` lines 54-55 |
| 5 | Image tagged: `latest`, `vX.Y.Z`, Git SHA | ✓ | Metadata action lines 69-73; tag matrix verified for all 3 triggers |
| 6 | Multi-arch: `linux/amd64`, `linux/arm64` | ✓ | `platforms:` line 82; Dockerfile uses `node:20-alpine` (multi-arch capable) |
| 7 | Vulnerability scan (Trivy) | ✓ | Step 7, severity CRITICAL,HIGH, exit-code 1 |
| 8 | README includes pull command | ✓ | `docker pull di3twater/crosstown-bls:latest` in README Quick Start |

### Improvements Checklist

- [x] YAML syntax validated (Python yaml.safe_load — VALID)
- [x] All 8 ACs verified with traceability evidence
- [x] Tag logic reviewed for all 3 trigger scenarios + edge case (manual dispatch without version)
- [x] 771 tests passing (32 test files) — no regressions
- [x] Dockerfile verified for multi-arch compatibility (node:20-alpine, python3/make/g++ in builder)
- [x] `.dockerignore` excludes `.github/` — workflow files won't bloat Docker context
- [ ] Add `if: always()` to SBOM generation/upload steps so SBOM is produced even when Trivy scan fails (FIND-06)
- [ ] Consider `--ignore-unfixed` in Trivy to reduce noise from CVEs without patches (future)
- [ ] Consider stricter semver pattern `bls-v(\d+\.\d+\.\d+)` in metadata-action (FIND-08, future)
- [ ] Consider a PR-triggered dry-run workflow for syntax validation (future)

### Security Review

- Docker Hub credentials correctly reference GitHub secrets (never hardcoded)
- Workflow permissions scoped to `contents: read` (least privilege)
- No secret values exposed in logs (GitHub Actions auto-masks)
- Trivy scan with exit-code 1 fails the workflow on CRITICAL/HIGH vulnerabilities (post-push, see FIND-07)
- No security concerns found

### Performance Considerations

- Build cache (`type=gha,mode=max`) configured for faster subsequent builds
- Concurrency group cancels in-flight builds, reducing wasted CI minutes
- QEMU + Buildx for multi-arch is inherently slower than single-arch, but necessary for AC 6
- No performance concerns

### Files Modified During Review

None.

### Gate Status

Gate: PASS → docs/qa/gates/5.5-docker-hub-publishing.yml

### Recommended Status

✓ Ready for Done — All 8 ACs met, clean implementation, no blocking issues. Three low/medium findings are all non-blocking future improvements.
(Story owner decides final status)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-07 | 0.1 | Initial story draft | SM (Claude Opus 4.6) |
| 2026-02-07 | 0.2 | Validation fixes: pin Trivy action version, fix Task 4 test file confusion, correct security source attribution, add concurrency config, add SBOM generation step | QA (Claude Opus 4.6) |
| 2026-02-07 | 0.3 | QA Review: PASS — All 8 ACs met, clean workflow implementation, 771 tests passing | Quinn (Test Architect) |
| 2026-02-07 | 0.4 | QA Review R2: PASS — Independent re-review, 3 new findings (CI-001 medium, CI-002/003 low), all non-blocking | Quinn (Test Architect) |
