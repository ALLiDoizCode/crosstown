# Story 4.6: Self-Write Bypass

## Status

Done

## Story

**As an** agent operator,
**I want** my own events stored without payment,
**so that** I don't pay myself to write to my own relay.

## Acceptance Criteria

1. Relay configured with owner pubkey
2. Events signed by owner pubkey bypass payment verification
3. Owner events still go through normal validation (valid signature, etc.)
4. Unit tests verify bypass for owner and payment requirement for others

## Tasks / Subtasks

- [x] Task 1: Extend BlsConfig to include ownerPubkey (AC: 1)
  - [x] Update `packages/relay/src/bls/types.ts`
  - [x] Add `ownerPubkey?: string` field to `BlsConfig` interface:
    ```typescript
    interface BlsConfig {
      /** Base price per byte for event storage (used for simple pricing) */
      basePricePerByte: bigint;
      /** Optional PricingService for kind-based pricing overrides */
      pricingService?: PricingService;
      /** Optional owner pubkey - events from this pubkey bypass payment */
      ownerPubkey?: string;
    }
    ```
  - [x] Validate ownerPubkey format if provided (64-character hex string)

- [x] Task 2: Implement self-write bypass logic in BusinessLogicServer (AC: 2, 3)
  - [x] Update `packages/relay/src/bls/BusinessLogicServer.ts`
  - [x] In `handlePayment()` method, after signature verification:
    - [x] Check if `event.pubkey === this.config.ownerPubkey`
    - [x] If match: skip price calculation and payment verification
    - [x] Store event directly and return accept response
  - [x] Ensure owner events still pass signature verification (AC: 3)
  - [x] Maintain existing payment flow for non-owner pubkeys

- [x] Task 3: Add pubkey validation utility (AC: 1)
  - [x] Create `isValidPubkey(pubkey: string): boolean` function in `types.ts`
  - [x] Validate: 64 characters, lowercase hex only
  - [x] Throw `BlsError` in constructor if `ownerPubkey` is invalid format

- [x] Task 4: Update module exports (AC: 1, 2)
  - [x] Export `isValidPubkey` from `packages/relay/src/bls/index.ts`
  - [x] Ensure `BlsConfig` type export includes new `ownerPubkey` field

- [x] Task 5: Write unit tests for self-write bypass (AC: 1-4)
  - [x] Add tests to `packages/relay/src/bls/BusinessLogicServer.test.ts`
  - [x] Test: Owner pubkey events accepted with amount=0
  - [x] Test: Owner pubkey events still require valid signature
  - [x] Test: Owner pubkey events are stored successfully
  - [x] Test: Non-owner pubkey events still require payment
  - [x] Test: BLS without ownerPubkey requires payment for all events
  - [x] Test: Invalid ownerPubkey format throws BlsError on construction

- [x] Task 6: Write integration tests for self-write bypass (AC: 1-4)
  - [x] Test: Full flow with owner pubkey bypass and SqliteEventStore
  - [x] Test: Mix of owner and non-owner events in sequence
  - [x] Verify owner events retrievable after bypass storage

## Dev Notes

### Previous Story Insights
[Source: docs/stories/4.5.story.md#dev-agent-record]

From Story 4.5 implementation:
- PricingService with kind overrides fully integrated into BLS
- BusinessLogicServer.handlePayment() calculates price using either:
  - `pricingService.calculatePriceFromBytes(toonBytes, event.kind)` if PricingService provided
  - `BigInt(toonBytes.length) * this.config.basePricePerByte` otherwise
- Pattern: Extend BlsConfig interface for new optional features
- Pattern: Check optional config fields with simple conditional
- All 542 tests pass in the project

### Architecture: BLS Payment Flow
[Source: docs/stories/4.4.story.md#dev-notes]

Current payment flow in `BusinessLogicServer.handlePayment()`:
1. Validate required fields (amount, destination, data)
2. Decode base64 data to TOON bytes
3. Decode TOON to Nostr event
4. **Verify event signature** (must remain for all events including owner)
5. Calculate price
6. Compare amount with price
7. If sufficient: store event and return accept
8. If insufficient: return reject with F06

The self-write bypass modifies step 5-7: if `event.pubkey === ownerPubkey`, skip price calculation and payment comparison, proceed directly to storage.

### Data Models
[Source: packages/relay/src/bls/types.ts]

Current `BlsConfig` structure:
```typescript
interface BlsConfig {
  /** Base price per byte for event storage (used for simple pricing) */
  basePricePerByte: bigint;
  /** Optional PricingService for kind-based pricing overrides */
  pricingService?: PricingService;
}
```

After this story:
```typescript
interface BlsConfig {
  basePricePerByte: bigint;
  pricingService?: PricingService;
  /** Optional owner pubkey - events from this pubkey bypass payment */
  ownerPubkey?: string;
}
```

### Nostr Pubkey Format
[Source: nostr-tools documentation, NIP-01]

Nostr pubkeys are 32-byte (256-bit) public keys encoded as 64-character lowercase hex strings.

Example valid pubkey:
```
"3bf0c63fcb93463407af97a5e5ee64fa883d107ef9e558472c4eb9aaaefa459d"
```

Validation regex:
```typescript
const PUBKEY_REGEX = /^[0-9a-f]{64}$/;
```

### Project Structure
[Source: docs/architecture/9-source-tree.md]

Files to modify for this story:
```
packages/relay/src/
└── bls/
    ├── types.ts                   # Add ownerPubkey to BlsConfig, add isValidPubkey
    ├── BusinessLogicServer.ts     # Add self-write bypass logic in handlePayment
    ├── BusinessLogicServer.test.ts # Add unit and integration tests
    └── index.ts                   # Export isValidPubkey
```

### Implementation Pattern
[Source: packages/relay/src/bls/BusinessLogicServer.ts]

Insert bypass logic after signature verification, before price calculation:

```typescript
// After: if (!verifyEvent(event)) { return reject... }

// NEW: Self-write bypass for owner
if (this.config.ownerPubkey && event.pubkey === this.config.ownerPubkey) {
  // Owner events bypass payment - store directly
  try {
    this.eventStore.store(event);
  } catch (error) {
    throw new BlsError(
      `Failed to store event: ${error instanceof Error ? error.message : 'Unknown error'}`,
      'STORAGE_ERROR'
    );
  }

  return {
    accept: true,
    fulfillment: generateFulfillment(event.id),
    metadata: {
      eventId: event.id,
      storedAt: Date.now(),
    },
  };
}

// Continue with price calculation for non-owner events...
```

### Tech Stack
[Source: docs/architecture/3-tech-stack.md]

| Technology | Version | Purpose |
|------------|---------|---------|
| TypeScript | 5.3.x | Language |
| nostr-tools | 2.x | Event types, pubkey handling |
| Vitest | 1.x | Unit testing |
| Hono | 4.x | BLS HTTP framework |

### Coding Standards
[Source: docs/architecture/12-coding-standards.md]

| Element | Convention | Example |
|---------|------------|---------|
| Files | kebab-case or PascalCase | `BusinessLogicServer.ts` |
| Classes | PascalCase | `BusinessLogicServer` |
| Functions | camelCase | `isValidPubkey` |
| Constants | UPPER_SNAKE_CASE | `PUBKEY_REGEX` |
| Interfaces | PascalCase | `BlsConfig` |

### Testing
[Source: docs/architecture/13-test-strategy-and-standards.md]

**Framework:** Vitest 1.x

**Test File Location:** Co-located with source (`BusinessLogicServer.test.ts`)

**Coverage Requirements:** >80% for public APIs

**Test Organization:** Follow AAA pattern (Arrange, Act, Assert)

**Test Helpers:**
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { generateSecretKey, finalizeEvent, getPublicKey } from 'nostr-tools/pure';
import type { NostrEvent } from 'nostr-tools/pure';
import { BusinessLogicServer } from './BusinessLogicServer.js';
import { encodeEventToToon } from '../toon/index.js';

// Helper to create event from specific secret key
function createEventFromKey(sk: Uint8Array, overrides = {}): NostrEvent {
  return finalizeEvent({
    kind: 1,
    content: 'test content',
    tags: [],
    created_at: Math.floor(Date.now() / 1000),
    ...overrides,
  }, sk);
}

// Helper to encode event to base64 TOON format for BLS requests
function eventToBase64Toon(event: NostrEvent): string {
  const toonData = encodeEventToToon(event);
  return Buffer.from(toonData).toString('base64');
}

describe('BusinessLogicServer with ownerPubkey', () => {
  let ownerSk: Uint8Array;
  let ownerPubkey: string;
  let mockEventStore: EventStore;
  let bls: BusinessLogicServer;

  beforeEach(() => {
    ownerSk = generateSecretKey();
    ownerPubkey = getPublicKey(ownerSk);
    mockEventStore = {
      store: vi.fn(),
      get: vi.fn(),
      query: vi.fn().mockReturnValue([]),
      close: vi.fn(),
    };
    bls = new BusinessLogicServer(
      { basePricePerByte: 10n, ownerPubkey },
      mockEventStore
    );
  });

  it('should accept owner events with zero payment', async () => {
    const event = createEventFromKey(ownerSk);
    const base64Data = eventToBase64Toon(event);

    const response = await bls.getApp().request('/handle-payment', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        amount: '0',
        destination: 'g.agent.test',
        data: base64Data,
      }),
    });

    expect(response.status).toBe(200);
    const json = await response.json();
    expect(json.accept).toBe(true);
    expect(mockEventStore.store).toHaveBeenCalled();
  });

  it('should reject non-owner events with zero payment', async () => {
    const nonOwnerSk = generateSecretKey();
    const event = createEventFromKey(nonOwnerSk);
    const base64Data = eventToBase64Toon(event);

    const response = await bls.getApp().request('/handle-payment', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        amount: '0',
        destination: 'g.agent.test',
        data: base64Data,
      }),
    });

    expect(response.status).toBe(400);
    const json = await response.json();
    expect(json.accept).toBe(false);
    expect(json.code).toBe('F06');
  });
});
```

### Error Handling
[Source: docs/architecture/11-error-handling-strategy.md]

Use `BlsError` for BLS-specific validation errors:
```typescript
import { BlsError } from './types.js';

// In constructor, validate ownerPubkey format
if (config.ownerPubkey && !isValidPubkey(config.ownerPubkey)) {
  throw new BlsError(
    'Invalid ownerPubkey format: must be 64 lowercase hex characters',
    'INVALID_CONFIG'
  );
}
```

### Security Considerations
[Source: docs/architecture/14-security.md]

- **Signature verification required**: Owner events MUST still pass signature verification. The bypass only skips payment, not validation.
- **Case sensitivity**: Pubkey comparison must be case-insensitive or normalized to lowercase, as Nostr pubkeys are lowercase hex.
- **No authorization escalation**: The bypass only affects payment. Events still go through all other validation.

### Backwards Compatibility
[Source: This story requirement]

**Critical:** Existing BLS usage must continue to work without changes.

Current usage (no ownerPubkey):
```typescript
const bls = new BusinessLogicServer(
  { basePricePerByte: 10n },
  eventStore
);
// All events require payment
```

After this story (with ownerPubkey):
```typescript
const bls = new BusinessLogicServer(
  { basePricePerByte: 10n, ownerPubkey: 'abc123...' },
  eventStore
);
// Events from ownerPubkey bypass payment
// Events from other pubkeys still require payment
```

Without ownerPubkey (backwards compatible):
```typescript
const bls = new BusinessLogicServer(
  { basePricePerByte: 10n },
  eventStore
);
// Behaves exactly as before - all events require payment
```

### Scope Boundaries

**In Scope (this story):**
- ownerPubkey configuration in BlsConfig
- Self-write bypass for owner pubkey events
- Pubkey validation utility
- Unit and integration tests
- Backwards compatibility

**Out of Scope (deferred to Story 4.7):**
- Integration example with ILP-gated relay
- End-to-end demo

## Dev Agent Record

### Agent Model Used
Claude Opus 4.5

### File List

| File | Action | Description |
|------|--------|-------------|
| `packages/relay/src/bls/types.ts` | Modified | Added `ownerPubkey` to BlsConfig, added `isValidPubkey` function and `PUBKEY_REGEX` constant |
| `packages/relay/src/bls/BusinessLogicServer.ts` | Modified | Added constructor validation for ownerPubkey, added self-write bypass logic after signature verification |
| `packages/relay/src/bls/index.ts` | Modified | Exported `isValidPubkey` and `PUBKEY_REGEX` |
| `packages/relay/src/bls/BusinessLogicServer.test.ts` | Modified | Added 19 new tests for self-write bypass (unit + integration) |

### Debug Log References
None - implementation completed without issues.

### Completion Notes
- All 6 tasks completed successfully
- All 561 tests pass (including 47 in BusinessLogicServer.test.ts)
- Linting passes for bls directory
- Pre-existing TypeScript config issues unrelated to this story
- Implementation follows existing patterns from Story 4.5
- Backwards compatible - existing BLS usage without ownerPubkey unchanged

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-06 | 0.1 | Initial story draft | SM (Claude Opus 4.5) |
| 2026-02-06 | 0.2 | Added Testing subsection per template; added eventToBase64Toon helper definition | SM (Claude Opus 4.5) |
| 2026-02-06 | 1.0 | Implementation complete - all tasks done, 561 tests pass | Dev (Claude Opus 4.5) |

## QA Results

### Review Date: 2026-02-06

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

Excellent implementation that follows established patterns from Story 4.5. The self-write bypass feature is implemented cleanly with proper separation of concerns:

1. **Type Layer** (`types.ts`): `ownerPubkey` added to `BlsConfig`, `isValidPubkey()` utility function with `PUBKEY_REGEX` constant
2. **Logic Layer** (`BusinessLogicServer.ts`): Constructor validation for ownerPubkey format, bypass logic placed correctly after signature verification
3. **Export Layer** (`index.ts`): All new exports properly exposed

The implementation correctly maintains security by ensuring signature verification happens before any bypass logic - owner events still go through all validation except payment.

### Refactoring Performed

None required - implementation is clean and follows project conventions.

### Compliance Check

- Coding Standards: ✓ All naming conventions followed (PascalCase for interfaces, camelCase for functions, UPPER_SNAKE_CASE for constants)
- Project Structure: ✓ Files in correct locations, co-located tests
- Testing Strategy: ✓ AAA pattern used, comprehensive coverage, proper mocking
- All ACs Met: ✓ All 4 acceptance criteria fully implemented and tested

### Improvements Checklist

- [x] ownerPubkey field added to BlsConfig (AC 1)
- [x] Self-write bypass logic implemented (AC 2)
- [x] Signature verification maintained for owner events (AC 3)
- [x] Comprehensive unit tests (10 new tests) (AC 4)
- [x] Comprehensive integration tests (3 new tests) (AC 4)
- [x] isValidPubkey utility function with 6 unit tests
- [x] Constructor validation throws BlsError on invalid ownerPubkey format
- [x] Backwards compatibility maintained - BLS without ownerPubkey works unchanged

### Security Review

**PASS** - No security concerns:
- Signature verification is mandatory for ALL events including owner (line 119 in BusinessLogicServer.ts)
- Bypass only skips payment verification, not event validation
- Pubkey validation prevents malformed configuration
- No authorization escalation possible

### Performance Considerations

**PASS** - Negligible impact:
- Single string comparison (`event.pubkey === this.config.ownerPubkey`) - O(1)
- Bypass occurs after signature verification, before price calculation
- No additional I/O or cryptographic operations

### Files Modified During Review

None - implementation is ready as-is.

### Gate Status

Gate: **PASS** → docs/qa/gates/4.6-self-write-bypass.yml

### Recommended Status

✓ **Ready for Done** - All acceptance criteria met, comprehensive test coverage (47 tests in file, 19 new for this story), clean implementation following established patterns. Optional future consideration: add toLowerCase() to pubkey comparison for defense-in-depth.
