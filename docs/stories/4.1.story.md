# Story 4.1: Basic Nostr Relay (Read Path)

## Status

Done

## Story

**As a** relay operator,
**I want** a WebSocket server that handles NIP-01 read operations,
**so that** clients can query events without payment.

## Acceptance Criteria

1. WebSocket server accepts connections on configurable port
2. Server handles NIP-01 `REQ` messages with subscription filters
3. Server responds with matching events from in-memory store
4. Server sends `EOSE` (end of stored events) after initial results
5. Server handles `CLOSE` messages to terminate subscriptions
6. Unit tests verify REQ/EOSE/CLOSE message handling

## Tasks / Subtasks

- [x] Task 1: Set up relay package dependencies (AC: 1)
  - [x] Add `ws` (8.x) to `packages/relay/package.json` for WebSocket server
  - [x] Add `@types/ws` as dev dependency
  - [x] Run `pnpm install` to update lockfile
  - [x] Verify build still passes with new dependencies

- [x] Task 2: Define relay configuration types (AC: 1)
  - [x] Create `packages/relay/src/types.ts` file
  - [x] Define `RelayConfig` interface with:
    - `port: number` (default 7000)
    - `maxConnections?: number` (default 100)
    - `maxSubscriptionsPerConnection?: number` (default 20)
    - `maxFiltersPerSubscription?: number` (default 10)
  - [x] Define `DEFAULT_RELAY_CONFIG` constant with sensible defaults
  - [x] Export types from `packages/relay/src/index.ts`

- [x] Task 3: Create in-memory event store (AC: 3)
  - [x] Create `packages/relay/src/storage/InMemoryEventStore.ts`
  - [x] Create `packages/relay/src/storage/index.ts` for exports
  - [x] Define `EventStore` interface with `store(event)`, `query(filters)`, `get(id)` methods
  - [x] Implement `InMemoryEventStore` class using `Map<string, NostrEvent>`
  - [x] Implement `store(event: NostrEvent): void` - store event by id
  - [x] Implement `get(id: string): NostrEvent | undefined` - retrieve single event
  - [x] Implement `query(filters: Filter[]): NostrEvent[]` - filter and return matching events
  - [x] Export from `packages/relay/src/index.ts`

- [x] Task 4: Implement NIP-01 filter matching logic (AC: 2, 3)
  - [x] Create `packages/relay/src/filters/matchFilter.ts`
  - [x] Create `packages/relay/src/filters/index.ts` for exports
  - [x] Implement `matchFilter(event: NostrEvent, filter: Filter): boolean`
  - [x] Handle `ids` filter (event id prefix matching)
  - [x] Handle `authors` filter (pubkey prefix matching)
  - [x] Handle `kinds` filter (exact kind matching)
  - [x] Handle `since` filter (created_at >= since)
  - [x] Handle `until` filter (created_at <= until)
  - [x] Handle `#e`, `#p` and generic `#<single-letter>` tag filters
  - [x] Handle `limit` in query (return at most N events, sorted by created_at desc)
  - [x] Empty filter matches all events
  - [x] Export from `packages/relay/src/index.ts`

- [x] Task 5: Create WebSocket connection handler (AC: 1, 2, 4, 5)
  - [x] Create `packages/relay/src/websocket/ConnectionHandler.ts`
  - [x] Create `packages/relay/src/websocket/index.ts` for exports
  - [x] Define `Subscription` type with `id: string`, `filters: Filter[]`
  - [x] Create `ConnectionHandler` class accepting WebSocket, EventStore, and RelayConfig
  - [x] Store active subscriptions in `Map<string, Subscription>` per connection
  - [x] Implement `handleMessage(data: string): void` to parse and route messages
  - [x] Implement private `handleReq(subscriptionId: string, ...filters: Filter[])` method
  - [x] Implement private `handleClose(subscriptionId: string)` method
  - [x] Export from `packages/relay/src/index.ts`

- [x] Task 6: Implement REQ message handling (AC: 2, 3, 4)
  - [x] Parse `["REQ", subscriptionId, ...filters]` message format
  - [x] Validate subscriptionId is a non-empty string
  - [x] Enforce `maxSubscriptionsPerConnection` limit - reject with NOTICE if exceeded
  - [x] Enforce `maxFiltersPerSubscription` limit - reject with NOTICE if exceeded
  - [x] Store subscription with its filters
  - [x] Query EventStore with filters
  - [x] Send matching events as `["EVENT", subscriptionId, event]` messages
  - [x] Send `["EOSE", subscriptionId]` after all stored events sent
  - [x] Handle errors by sending `["NOTICE", errorMessage]`

- [x] Task 7: Implement CLOSE message handling (AC: 5)
  - [x] Parse `["CLOSE", subscriptionId]` message format
  - [x] Remove subscription from active subscriptions map
  - [x] Gracefully handle CLOSE for non-existent subscriptions (no error)

- [x] Task 8: Create WebSocket server class (AC: 1)
  - [x] Create `packages/relay/src/websocket/NostrRelayServer.ts`
  - [x] Create `NostrRelayServer` class with constructor accepting `RelayConfig` and `EventStore`
  - [x] Use `ws` library to create WebSocket.Server
  - [x] Create ConnectionHandler for each new connection
  - [x] Implement `start(): Promise<void>` method to begin listening
  - [x] Implement `stop(): Promise<void>` method to close server and all connections
  - [x] Implement `getPort(): number` method to return actual listening port
  - [x] Track connected clients count for potential maxConnections enforcement
  - [x] Export from `packages/relay/src/index.ts`

- [x] Task 9: Handle connection lifecycle (AC: 1, 5)
  - [x] Log connection open events
  - [x] Handle `message` events by delegating to ConnectionHandler
  - [x] Handle `close` events by cleaning up subscriptions
  - [x] Handle `error` events gracefully
  - [x] Validate incoming messages are valid JSON arrays

- [x] Task 10: Write unit tests for in-memory event store (AC: 3, 6)
  - [x] Create `packages/relay/src/storage/InMemoryEventStore.test.ts`
  - [x] Test storing and retrieving events
  - [x] Test query with empty filters returns all events
  - [x] Test query with kind filter
  - [x] Test query with author filter
  - [x] Test query with since/until filters
  - [x] Test query with limit
  - [x] Test query returns events sorted by created_at desc

- [x] Task 11: Write unit tests for filter matching (AC: 2, 6)
  - [x] Create `packages/relay/src/filters/matchFilter.test.ts`
  - [x] Test ids filter with exact match
  - [x] Test ids filter with prefix match
  - [x] Test authors filter with exact match
  - [x] Test authors filter with prefix match
  - [x] Test kinds filter
  - [x] Test since filter
  - [x] Test until filter
  - [x] Test tag filters (#e, #p)
  - [x] Test combined filters (AND logic)
  - [x] Test empty filter matches everything

- [x] Task 12: Write unit tests for ConnectionHandler (AC: 2, 4, 5, 6)
  - [x] Create `packages/relay/src/websocket/ConnectionHandler.test.ts`
  - [x] Create mock WebSocket implementation for testing
  - [x] Test REQ message creates subscription
  - [x] Test REQ message sends matching events
  - [x] Test REQ message sends EOSE after events
  - [x] Test CLOSE message removes subscription
  - [x] Test CLOSE for non-existent subscription doesn't error
  - [x] Test invalid JSON sends NOTICE
  - [x] Test invalid message format sends NOTICE
  - [x] Test REQ rejected with NOTICE when maxSubscriptionsPerConnection exceeded
  - [x] Test REQ rejected with NOTICE when maxFiltersPerSubscription exceeded

- [x] Task 13: Write unit tests for NostrRelayServer (AC: 1, 6)
  - [x] Create `packages/relay/src/websocket/NostrRelayServer.test.ts`
  - [x] Test server starts on configured port
  - [x] Test server accepts WebSocket connections
  - [x] Test server can be stopped cleanly
  - [x] Test multiple clients can connect
  - [x] Test integration: REQ → EVENT → EOSE flow

- [x] Task 14: Update package exports (AC: 1, 2, 3, 4, 5)
  - [x] Export `NostrRelayServer` from `packages/relay/src/index.ts`
  - [x] Export `InMemoryEventStore` and `EventStore` interface
  - [x] Export `RelayConfig` and `DEFAULT_RELAY_CONFIG`
  - [x] Export `ConnectionHandler` for extensibility
  - [x] Export `matchFilter` utility function
  - [x] Verify types are correctly exported in build output

## Dev Notes

### Previous Story Insights
[Source: docs/stories/3.4.story.md#dev-agent-record]

From Story 3.4 implementation:
- 329 tests currently passing in core package
- Pattern for config merging: `{ ...DEFAULT_CONFIG, ...providedConfig }`
- Pattern for constants: UPPER_SNAKE_CASE with sensible defaults exported
- All new public APIs exported from index.ts files

This is the first story in Epic 4, which begins the `@agent-society/relay` package implementation. The relay package currently only has a placeholder `VERSION` export.

### Project Structure
[Source: docs/architecture/9-source-tree.md]

Files to create for this story:
```
packages/relay/src/
├── index.ts                        # Package exports (modify existing)
├── types.ts                        # RelayConfig interface (create)
├── storage/
│   ├── index.ts                    # Storage module exports
│   ├── InMemoryEventStore.ts       # In-memory event storage
│   └── InMemoryEventStore.test.ts  # Tests
├── filters/
│   ├── index.ts                    # Filters module exports
│   ├── matchFilter.ts              # NIP-01 filter matching
│   └── matchFilter.test.ts         # Tests
└── websocket/
    ├── index.ts                    # WebSocket module exports
    ├── ConnectionHandler.ts        # Per-connection message handler
    ├── ConnectionHandler.test.ts   # Tests
    ├── NostrRelayServer.ts         # Main WebSocket server
    └── NostrRelayServer.test.ts    # Tests
```

### Tech Stack
[Source: docs/architecture/3-tech-stack.md]

| Technology | Version | Purpose |
|------------|---------|---------|
| ws | 8.x | WebSocket server implementation |
| nostr-tools | 2.x | Nostr types (NostrEvent, Filter) |
| Vitest | 1.x | Unit testing |
| TypeScript | 5.3.x | Language |

### NIP-01 Protocol Reference
[Source: NIP-01 specification]

**Client Message Formats:**
- `["REQ", <subscription_id>, <filter1>, <filter2>, ...]` - Subscribe to events
- `["CLOSE", <subscription_id>]` - Close subscription

**Server Message Formats:**
- `["EVENT", <subscription_id>, <event>]` - Event matching subscription
- `["EOSE", <subscription_id>]` - End of stored events
- `["NOTICE", <message>]` - Human-readable message

**Filter Object (nostr-tools Filter type):**
```typescript
interface Filter {
  ids?: string[];       // Event IDs (prefix match)
  authors?: string[];   // Pubkeys (prefix match)
  kinds?: number[];     // Event kinds (exact match)
  since?: number;       // Unix timestamp (>=)
  until?: number;       // Unix timestamp (<=)
  limit?: number;       // Max events to return
  [key: `#${string}`]: string[];  // Tag filters
}
```

**Filter Matching Rules:**
- All specified fields must match (AND logic)
- `ids` and `authors` support prefix matching (e.g., "abc" matches "abcdef")
- Tag filters: `#e` matches events with `["e", "value"]` tag
- Multiple filters in REQ: events matching ANY filter are returned (OR logic)
- Empty filter `{}` matches all events

### Component Architecture
[Source: docs/architecture/5-components.md#52-agent-societyrelay]

The `@agent-society/relay` package provides:
- **WebSocket Server** - NIP-01 compliant read path
- **EventStore** - Pluggable storage (in-memory for this story, SQLite in Story 4.2)

Key design decisions:
- EventStore is an interface to allow different storage backends
- ConnectionHandler manages per-connection state (subscriptions)
- NostrRelayServer orchestrates connections and delegates to handlers

### Error Handling
[Source: docs/architecture/11-error-handling-strategy.md]

- Use `RelayError` class for relay-specific errors
- Send `["NOTICE", message]` for protocol-level errors visible to clients
- Log errors but don't crash on individual connection failures
- Close connections gracefully on unrecoverable errors

```typescript
class RelayError extends AgentSocietyError {
  constructor(message: string, code: string, cause?: Error) {
    super(message, code, cause);
    this.name = 'RelayError';
  }
}
```

### Security Considerations
[Source: docs/architecture/14-security.md]

For this story (read-only relay):
- Validate all incoming JSON messages (prevent injection)
- Limit subscription count per connection via `maxSubscriptionsPerConnection` (default: 20)
- Limit filter count per subscription via `maxFiltersPerSubscription` (default: 10)
- Use nostr-tools types for type safety
- No authentication required for reads (public data)

**Limit Enforcement:**
- When a client exceeds `maxSubscriptionsPerConnection`, reject REQ with `["NOTICE", "error: too many subscriptions"]`
- When a REQ contains more filters than `maxFiltersPerSubscription`, reject with `["NOTICE", "error: too many filters"]`
- Both limits are configurable in `RelayConfig`

Future stories will add:
- Event signature verification (Story 4.4)
- Payment verification (Story 4.4)

### Coding Standards
[Source: docs/architecture/12-coding-standards.md]

| Element | Convention | Example |
|---------|------------|---------|
| Files | kebab-case | `match-filter.ts` (note: source tree shows `matchFilter.ts`, either acceptable) |
| Classes | PascalCase | `NostrRelayServer`, `ConnectionHandler` |
| Interfaces | PascalCase | `EventStore`, `RelayConfig` |
| Functions | camelCase | `matchFilter`, `handleReq` |
| Constants | UPPER_SNAKE_CASE | `DEFAULT_RELAY_CONFIG` |

### Testing Requirements
[Source: docs/architecture/13-test-strategy-and-standards.md]

**Framework:** Vitest 1.x

**Test File Location:** Co-located with source (e.g., `ConnectionHandler.test.ts`)

**Test Structure:**
```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { NostrRelayServer } from './NostrRelayServer.js';
import type { EventStore } from '../storage/index.js';

describe('NostrRelayServer', () => {
  let server: NostrRelayServer;
  let mockStore: EventStore;

  beforeEach(() => {
    mockStore = {
      store: vi.fn(),
      get: vi.fn(),
      query: vi.fn().mockReturnValue([]),
    };
    server = new NostrRelayServer({ port: 0 }, mockStore);
  });

  afterEach(async () => {
    await server.stop();
  });

  it('should start on configured port', async () => {
    await server.start();
    expect(server.getPort()).toBeGreaterThan(0);
  });
});
```

**Mock WebSocket for Testing:**
```typescript
// Create a mock WebSocket for unit testing ConnectionHandler
const createMockWebSocket = () => ({
  send: vi.fn(),
  close: vi.fn(),
  readyState: 1, // OPEN
  on: vi.fn(),
  once: vi.fn(),
  removeListener: vi.fn(),
});
```

**Coverage Requirement:** >80% for public APIs

### Dependencies
[Source: packages/relay/package.json]

Current dependencies:
```json
{
  "dependencies": {
    "@agent-society/core": "workspace:*"
  }
}
```

Need to add:
```json
{
  "dependencies": {
    "@agent-society/core": "workspace:*",
    "ws": "^8.0.0"
  },
  "devDependencies": {
    "@types/ws": "^8.0.0"
  }
}
```

Note: Use `nostr-tools` types from `@agent-society/core` re-exports or import directly from nostr-tools.

## Dev Agent Record

### Agent Model Used
Claude Opus 4.5 (claude-opus-4-5-20251101)

### Debug Log References
No debug log entries required - implementation completed without blocking issues.

### Completion Notes
- Implemented NIP-01 compliant WebSocket relay with read path (REQ, EOSE, CLOSE)
- Added `nostr-tools` as direct dependency to relay package for type access
- All 67 new tests pass (396 total across repository)
- Linting passes with no errors
- Build output includes properly typed exports

### File List
**New Files:**
- `packages/relay/src/types.ts` - RelayConfig interface and DEFAULT_RELAY_CONFIG
- `packages/relay/src/storage/InMemoryEventStore.ts` - In-memory event storage implementation
- `packages/relay/src/storage/InMemoryEventStore.test.ts` - Event store unit tests (15 tests)
- `packages/relay/src/storage/index.ts` - Storage module exports
- `packages/relay/src/filters/matchFilter.ts` - NIP-01 filter matching logic
- `packages/relay/src/filters/matchFilter.test.ts` - Filter matching unit tests (29 tests)
- `packages/relay/src/filters/index.ts` - Filters module exports
- `packages/relay/src/websocket/ConnectionHandler.ts` - Per-connection message handler
- `packages/relay/src/websocket/ConnectionHandler.test.ts` - Connection handler unit tests (15 tests)
- `packages/relay/src/websocket/NostrRelayServer.ts` - Main WebSocket server
- `packages/relay/src/websocket/NostrRelayServer.test.ts` - Server integration tests (8 tests)
- `packages/relay/src/websocket/index.ts` - WebSocket module exports

**Modified Files:**
- `packages/relay/package.json` - Added ws, @types/ws, nostr-tools dependencies
- `packages/relay/src/index.ts` - Added exports for all new public APIs

## QA Results

### Review Date: 2026-02-06

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall: Excellent**

The implementation demonstrates strong adherence to NIP-01 specifications and follows established project patterns. Code is well-organized with clear separation of concerns across four modules (types, storage, filters, websocket). The implementation is clean, idiomatic TypeScript with proper use of interfaces and types from nostr-tools.

**Highlights:**
- Clean interface design for `EventStore` enabling future backend flexibility (SQLite in Story 4.2)
- Proper use of `Required<RelayConfig>` pattern for configuration merging
- Comprehensive filter matching implementation covering all NIP-01 filter types
- Well-structured connection lifecycle management with proper cleanup

### Refactoring Performed

None required. The code quality is high and follows project standards well.

### Compliance Check

- Coding Standards: ✓ All naming conventions followed (PascalCase classes, camelCase functions, UPPER_SNAKE_CASE constants)
- Project Structure: ✓ Files organized per source-tree spec with proper index.ts exports
- Testing Strategy: ✓ Co-located test files, >80% coverage, AAA pattern followed
- All ACs Met: ✓ All 6 acceptance criteria fully implemented and tested

### Improvements Checklist

All items handled by implementation - no changes required:

- [x] WebSocket server accepts connections on configurable port (AC1)
- [x] NIP-01 REQ message handling with subscription filters (AC2)
- [x] In-memory event storage with query support (AC3)
- [x] EOSE sent after initial results (AC4)
- [x] CLOSE message handling for subscription termination (AC5)
- [x] Unit tests for REQ/EOSE/CLOSE (AC6) - 67 tests total

**Future Considerations (not blocking):**
- [ ] Consider adding event validation before storage (signature verification - Story 4.4)
- [ ] Consider adding a `count` method to EventStore interface for pagination support
- [ ] Consider extracting WebSocket message parsing to a dedicated module for reuse in write path

### Security Review

**Status: PASS**

- ✓ All incoming JSON is validated before processing
- ✓ `maxSubscriptionsPerConnection` limit enforced (default: 20)
- ✓ `maxFiltersPerSubscription` limit enforced (default: 10)
- ✓ `maxConnections` limit enforced at server level (default: 100)
- ✓ Graceful error handling prevents information leakage
- ✓ ReadyState check prevents sending to closed connections
- ✓ Uses nostr-tools types for type safety

No vulnerabilities identified. The read path correctly treats all data as public (no auth required per story scope).

### Performance Considerations

**Status: PASS**

- In-memory storage is O(n) for queries which is acceptable for MVP
- Events are sorted after filtering (could be optimized with sorted index if needed later)
- Limit applied after sorting ensures correct results for "most recent N" queries
- No memory leaks identified - subscriptions properly cleaned up on connection close

### Files Modified During Review

None - no refactoring was required.

### Gate Status

Gate: PASS → docs/qa/gates/4.1-basic-nostr-relay-read-path.yml

### Recommended Status

✓ Ready for Done

The implementation fully satisfies all acceptance criteria with comprehensive test coverage (67 tests). Code quality is excellent with proper separation of concerns and adherence to project standards.

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-06 | 0.1 | Initial story draft | SM |
| 2026-02-06 | 0.2 | Added security limits (maxSubscriptions, maxFilters) to config and tasks | SM |
| 2026-02-06 | 1.0 | Implementation complete - all 14 tasks done, 67 tests added | Dev (James) |
