# Story 4.2: Event Storage with SQLite

## Status

Done

## Story

**As a** relay operator,
**I want** events persisted to SQLite,
**so that** events survive relay restarts.

## Acceptance Criteria

1. SQLite database created with events table (id, pubkey, kind, content, tags, created_at, sig)
2. Events are stored on successful write
3. REQ queries read from SQLite with proper filtering
4. Replaceable events (kinds 10000-19999) replace previous events from same pubkey
5. Database file location is configurable
6. Unit tests verify persistence and replacement logic

## Tasks / Subtasks

- [x] Task 1: Add better-sqlite3 dependency (AC: 1)
  - [x] Add `better-sqlite3` (^9.0.0) to `packages/relay/package.json` dependencies
  - [x] Add `@types/better-sqlite3` as dev dependency
  - [x] Run `pnpm install` to update lockfile
  - [x] Verify build still passes with new dependency

- [x] Task 2: Create SQLite schema initialization (AC: 1)
  - [x] Create `packages/relay/src/storage/SqliteEventStore.ts`
  - [x] Define schema SQL constant with events table:
    ```sql
    CREATE TABLE IF NOT EXISTS events (
      id TEXT PRIMARY KEY,
      pubkey TEXT NOT NULL,
      kind INTEGER NOT NULL,
      content TEXT NOT NULL,
      tags TEXT NOT NULL,
      created_at INTEGER NOT NULL,
      sig TEXT NOT NULL,
      received_at INTEGER NOT NULL
    )
    ```
  - [x] Add indexes: `idx_events_pubkey`, `idx_events_kind`, `idx_events_created_at`, `idx_events_pubkey_kind`
  - [x] Implement `initializeSchema(db: Database)` function to create tables/indexes

- [x] Task 3: Implement SqliteEventStore class - constructor (AC: 1, 5)
  - [x] Create `SqliteEventStore` class implementing `EventStore` interface
  - [x] Constructor accepts `dbPath: string` parameter for database file location
  - [x] Use `:memory:` as default path for in-memory database (useful for testing)
  - [x] Open database connection with better-sqlite3
  - [x] Call `initializeSchema()` on construction
  - [x] Store database instance as private property

- [x] Task 4: Implement SqliteEventStore.store() method (AC: 2)
  - [x] Create prepared statement for INSERT OR REPLACE
  - [x] Convert event.tags array to JSON string for storage
  - [x] Add `received_at` timestamp (Date.now() / 1000 | 0)
  - [x] Execute insert with event fields: id, pubkey, kind, content, tags, created_at, sig, received_at
  - [x] Handle duplicate events gracefully (REPLACE handles this)
  - [x] Wrap any database errors in RelayError with code 'STORAGE_ERROR'

- [x] Task 5: Implement replaceable event logic (AC: 4)
  - [x] Check if event kind is in replaceable range (10000-19999)
  - [x] If replaceable, query existing event with same pubkey AND kind
  - [x] Only replace if new event has higher `created_at`, or same `created_at` with lower lexicographic `id` (per NIP-01)
  - [x] If replacing, DELETE existing event then INSERT new event
  - [x] Use transaction to ensure atomicity (BEGIN, DELETE, INSERT, COMMIT)
  - [x] Also handle parameterized replaceable events (kinds 30000-39999) with `d` tag matching
  - [x] Regular events (kinds < 10000 or 20000-29999) just use INSERT OR IGNORE

- [x] Task 6: Implement SqliteEventStore.get() method (AC: 2)
  - [x] Create prepared statement: `SELECT * FROM events WHERE id = ?`
  - [x] Parse tags from JSON string back to array
  - [x] Return undefined if event not found
  - [x] Return reconstructed NostrEvent object if found

- [x] Task 7: Implement SqliteEventStore.query() method (AC: 3)
  - [x] Build dynamic SQL query based on filter fields
  - [x] Handle `ids` filter with `id LIKE ?` for prefix matching
  - [x] Handle `authors` filter with `pubkey LIKE ?` for prefix matching
  - [x] Handle `kinds` filter with `kind IN (...)`
  - [x] Handle `since` filter with `created_at >= ?`
  - [x] Handle `until` filter with `created_at <= ?`
  - [x] Handle tag filters (`#e`, `#p`, etc.) using LIKE: `tags LIKE '%["e","value"%'` (simple approach per Dev Notes)
  - [x] Combine multiple filters with OR logic (match ANY filter)
  - [x] Apply `ORDER BY created_at DESC`
  - [x] Apply `LIMIT` from first filter that specifies it
  - [x] Parse tags JSON for each returned row
  - [x] Return array of NostrEvent objects

- [x] Task 8: Implement close() method (AC: 2)
  - [x] Add `close(): void` method to SqliteEventStore
  - [x] Close database connection
  - [x] Update EventStore interface to include optional `close?(): void` method
  - [x] InMemoryEventStore can implement as no-op

- [x] Task 9: Update EventStore interface and exports (AC: 2, 3)
  - [x] Add optional `close?(): void` to EventStore interface
  - [x] Export `SqliteEventStore` from `packages/relay/src/storage/index.ts`
  - [x] Export `SqliteEventStore` from `packages/relay/src/index.ts`

- [x] Task 10: Update RelayConfig for database path (AC: 5)
  - [x] Add `databasePath?: string` to RelayConfig interface in `packages/relay/src/types.ts`
  - [x] Default to `:memory:` if not specified
  - [x] Update DEFAULT_RELAY_CONFIG with `databasePath: ':memory:'`

- [x] Task 11: Write unit tests for schema initialization (AC: 1, 6)
  - [x] Create `packages/relay/src/storage/SqliteEventStore.test.ts`
  - [x] Test database creates events table on construction
  - [x] Test all indexes are created
  - [x] Test custom dbPath creates file at specified location
  - [x] Test `:memory:` creates in-memory database
  - [x] Clean up test database files after tests

- [x] Task 12: Write unit tests for store/get operations (AC: 2, 6)
  - [x] Test storing an event and retrieving by ID
  - [x] Test storing multiple events
  - [x] Test get returns undefined for non-existent ID
  - [x] Test event fields are correctly persisted and retrieved
  - [x] Test tags array is correctly serialized/deserialized

- [x] Task 13: Write unit tests for replaceable event logic (AC: 4, 6)
  - [x] Test kind 10000 event replaces previous event from same pubkey
  - [x] Test kind 10032 (ILP_PEER_INFO) replaces correctly
  - [x] Test kind 15000 event replaces previous event from same pubkey
  - [x] Test replaceable event doesn't replace event from different pubkey
  - [x] Test regular event (kind 1) doesn't replace anything
  - [x] Test parameterized replaceable event (kind 30000+) uses `d` tag for matching

- [x] Task 14: Write unit tests for query operations (AC: 3, 6)
  - [x] Test query with empty filters returns all events
  - [x] Test query with `ids` filter (exact match)
  - [x] Test query with `ids` filter (prefix match)
  - [x] Test query with `authors` filter
  - [x] Test query with `kinds` filter
  - [x] Test query with `since` filter
  - [x] Test query with `until` filter
  - [x] Test query with `limit`
  - [x] Test query with tag filters (#e, #p)
  - [x] Test query with multiple filters (OR logic)
  - [x] Test results are sorted by created_at descending

- [x] Task 15: Write integration test with NostrRelayServer (AC: 2, 3, 6)
  - [x] Create integration test using SqliteEventStore with NostrRelayServer
  - [x] Test REQ returns events from SQLite store
  - [x] Test events persist across server restart (file-based database)
  - [x] Test EOSE sent after SQLite query completes

## Dev Notes

### Previous Story Insights
[Source: docs/stories/4.1.story.md#dev-agent-record]

From Story 4.1 implementation:
- `EventStore` interface defined with `store(event)`, `get(id)`, `query(filters)` methods
- `InMemoryEventStore` provides reference implementation
- `matchFilter()` function handles NIP-01 filter matching logic
- `NostrRelayServer` and `ConnectionHandler` delegate to EventStore for queries
- 67 new tests added for relay package, 396 total across repository
- Pattern: EventStore interface allows swapping backends without changing server code

### Database Schema
[Source: docs/architecture/8-database-schema.md]

```sql
-- Events table
CREATE TABLE events (
    id TEXT PRIMARY KEY,           -- Event ID (hash)
    pubkey TEXT NOT NULL,          -- Author public key
    kind INTEGER NOT NULL,         -- Event kind
    content TEXT NOT NULL,         -- Event content
    tags TEXT NOT NULL,            -- JSON-encoded tags array
    created_at INTEGER NOT NULL,   -- Unix timestamp
    sig TEXT NOT NULL,             -- Schnorr signature
    received_at INTEGER NOT NULL   -- When relay received event
);

-- Indexes for common queries
CREATE INDEX idx_events_pubkey ON events(pubkey);
CREATE INDEX idx_events_kind ON events(kind);
CREATE INDEX idx_events_created_at ON events(created_at);
CREATE INDEX idx_events_pubkey_kind ON events(pubkey, kind);
```

**Design Notes:**
- Tags stored as JSON for flexibility
- `received_at` tracks when relay received event (for debugging/auditing)
- Replaceable events handled in application layer (delete old, insert new)
- No foreign keys; events are self-contained

### Tech Stack
[Source: docs/architecture/3-tech-stack.md]

| Technology | Version | Purpose |
|------------|---------|---------|
| better-sqlite3 | 9.x | Relay event storage - synchronous API, excellent performance, single-file |
| nostr-tools | 2.x | Nostr types (NostrEvent, Filter) |
| Vitest | 1.x | Unit testing |
| TypeScript | 5.3.x | Language |

### NIP-01 Replaceable Events
[Source: NIP-01 specification]

**Replaceable Event Kinds:**
- Kinds 10000-19999: Replaceable events - only the latest event per pubkey+kind is kept
- Kinds 30000-39999: Parameterized replaceable events - latest per pubkey+kind+`d`-tag

**Replacement Rules:**
1. When a new replaceable event arrives, delete any existing event with same (pubkey, kind)
2. For parameterized replaceable (30000-39999), match on (pubkey, kind, d-tag value)
3. The `d` tag value can be empty string, which is valid
4. Only keep the event with highest `created_at`; if equal, keep the one with lowest `id` lexicographically

### Project Structure
[Source: docs/architecture/9-source-tree.md]

Files to create/modify for this story:
```
packages/relay/src/
├── types.ts                        # Add databasePath to RelayConfig (modify)
├── storage/
│   ├── index.ts                    # Export SqliteEventStore (modify)
│   ├── InMemoryEventStore.ts       # Add optional close() method (modify)
│   ├── SqliteEventStore.ts         # SQLite implementation (create)
│   └── SqliteEventStore.test.ts    # Unit tests (create)
└── package.json                    # Add better-sqlite3 dependency (modify)
```

### EventStore Interface
[Source: packages/relay/src/storage/InMemoryEventStore.ts]

Current interface (does NOT have close() - must be added in Task 8):
```typescript
export interface EventStore {
  /** Store an event by its ID */
  store(event: NostrEvent): void;
  /** Retrieve a single event by ID */
  get(id: string): NostrEvent | undefined;
  /** Query events matching any of the provided filters */
  query(filters: Filter[]): NostrEvent[];
  // NOTE: close() method does NOT exist yet - add in Task 8
}
```

### Current RelayConfig
[Source: packages/relay/src/types.ts]

Current config (databasePath must be added in Task 10):
```typescript
export interface RelayConfig {
  port: number;
  maxConnections?: number;
  maxSubscriptionsPerConnection?: number;
  maxFiltersPerSubscription?: number;
  // NOTE: databasePath does NOT exist yet - add in Task 10
}

export const DEFAULT_RELAY_CONFIG: Required<RelayConfig> = {
  port: 7000,
  maxConnections: 100,
  maxSubscriptionsPerConnection: 20,
  maxFiltersPerSubscription: 10,
  // NOTE: databasePath: ':memory:' must be added in Task 10
};
```

### SQLite Query Building Pattern
[Source: Implementation guidance]

For building dynamic queries with filters:

```typescript
function buildQuerySql(filters: Filter[]): { sql: string; params: unknown[] } {
  if (filters.length === 0) {
    return { sql: 'SELECT * FROM events ORDER BY created_at DESC', params: [] };
  }

  const conditions: string[] = [];
  const params: unknown[] = [];

  for (const filter of filters) {
    const filterConditions: string[] = [];

    if (filter.ids?.length) {
      // Prefix matching with LIKE
      const idConditions = filter.ids.map(() => 'id LIKE ?');
      filterConditions.push(`(${idConditions.join(' OR ')})`);
      params.push(...filter.ids.map(id => `${id}%`));
    }

    if (filter.authors?.length) {
      const authorConditions = filter.authors.map(() => 'pubkey LIKE ?');
      filterConditions.push(`(${authorConditions.join(' OR ')})`);
      params.push(...filter.authors.map(a => `${a}%`));
    }

    if (filter.kinds?.length) {
      filterConditions.push(`kind IN (${filter.kinds.map(() => '?').join(', ')})`);
      params.push(...filter.kinds);
    }

    if (filter.since !== undefined) {
      filterConditions.push('created_at >= ?');
      params.push(filter.since);
    }

    if (filter.until !== undefined) {
      filterConditions.push('created_at <= ?');
      params.push(filter.until);
    }

    // Tag filters handled with JSON operations
    // ...

    if (filterConditions.length > 0) {
      conditions.push(`(${filterConditions.join(' AND ')})`);
    }
  }

  let sql = 'SELECT * FROM events';
  if (conditions.length > 0) {
    sql += ` WHERE ${conditions.join(' OR ')}`;
  }
  sql += ' ORDER BY created_at DESC';

  // Apply limit from first filter
  const limitFilter = filters.find(f => f.limit !== undefined);
  if (limitFilter?.limit !== undefined) {
    sql += ' LIMIT ?';
    params.push(limitFilter.limit);
  }

  return { sql, params };
}
```

### Tag Filter Matching in SQLite
[Source: Implementation guidance]

Tags are stored as JSON array. To match `#e` filter with value "abc":
```sql
-- Check if tags JSON contains a tag starting with "e" that has value "abc"
tags LIKE '%["e","abc"%'
```

More robust approach using JSON functions (if available):
```sql
-- SQLite JSON1 extension
EXISTS (
  SELECT 1 FROM json_each(tags)
  WHERE json_extract(value, '$[0]') = 'e'
  AND json_extract(value, '$[1]') = 'abc'
)
```

For simplicity in MVP, use the LIKE approach which is sufficient for most cases.

### Coding Standards
[Source: docs/architecture/12-coding-standards.md]

| Element | Convention | Example |
|---------|------------|---------|
| Files | kebab-case or PascalCase | `SqliteEventStore.ts` |
| Classes | PascalCase | `SqliteEventStore` |
| Functions | camelCase | `initializeSchema` |
| Constants | UPPER_SNAKE_CASE | `SCHEMA_SQL` |

**Critical Rules:**
- Never use `any` - use `unknown` and type guards
- Export from index.ts for public APIs
- Co-located test files

### Testing Requirements
[Source: docs/architecture/13-test-strategy-and-standards.md]

**Framework:** Vitest 1.x

**Test File Location:** Co-located with source (`SqliteEventStore.test.ts`)

**Test Pattern:**
```typescript
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { SqliteEventStore } from './SqliteEventStore.js';
import type { NostrEvent } from 'nostr-tools/pure';
import { unlinkSync, existsSync } from 'fs';

describe('SqliteEventStore', () => {
  let store: SqliteEventStore;
  const TEST_DB_PATH = './test-events.db';

  beforeEach(() => {
    store = new SqliteEventStore(TEST_DB_PATH);
  });

  afterEach(() => {
    store.close();
    if (existsSync(TEST_DB_PATH)) {
      unlinkSync(TEST_DB_PATH);
    }
  });

  // Helper to create test events
  const createTestEvent = (overrides: Partial<NostrEvent> = {}): NostrEvent => ({
    id: 'abc123...',
    pubkey: 'def456...',
    kind: 1,
    content: 'test',
    tags: [],
    created_at: Math.floor(Date.now() / 1000),
    sig: 'sig...',
    ...overrides,
  });

  it('should store and retrieve an event', () => {
    const event = createTestEvent();
    store.store(event);
    expect(store.get(event.id)).toEqual(event);
  });
});
```

### Error Handling
[Source: docs/architecture/11-error-handling-strategy.md]

- Use `RelayError` class for relay-specific errors
- SQLite errors should be wrapped in RelayError with code `'STORAGE_ERROR'`
- Database constraints (like PRIMARY KEY violation) are expected and handled gracefully
- Log errors but don't crash on transient database issues

### Security Considerations
[Source: docs/architecture/14-security.md]

- Use parameterized queries to prevent SQL injection (better-sqlite3 does this by default)
- Validate event structure before storing
- Database file permissions should be restricted to relay process user
- Don't log full event content (may contain sensitive data)

## Dev Agent Record

### Agent Model Used

Claude Opus 4.5

### Debug Log References

No debug issues encountered.

### Completion Notes

- Used `better-sqlite3` v11.x instead of v9.x due to Node.js v24.12.0 compatibility (v9.x failed to compile)
- Implemented full NIP-01 replaceable event logic for kinds 10000-19999 and parameterized replaceable events for kinds 30000-39999
- Empty d-tag handling required special logic to match events with missing d-tag (equivalent to d="")
- 41 new tests added (38 SqliteEventStore unit tests + 3 integration tests with NostrRelayServer)
- Total tests: 437 (up from 396)
- All linting and tests pass

### File List

| File | Action | Description |
|------|--------|-------------|
| `packages/relay/package.json` | Modified | Added better-sqlite3 ^11.0.0 dependency and @types/better-sqlite3 ^7.6.0 devDependency |
| `packages/relay/src/storage/SqliteEventStore.ts` | Created | SQLite implementation of EventStore with full NIP-01 compliance |
| `packages/relay/src/storage/SqliteEventStore.test.ts` | Created | 38 unit tests for SqliteEventStore |
| `packages/relay/src/storage/InMemoryEventStore.ts` | Modified | Added optional close?() method to EventStore interface and no-op implementation |
| `packages/relay/src/storage/index.ts` | Modified | Added exports for SqliteEventStore and RelayError |
| `packages/relay/src/index.ts` | Modified | Added exports for SqliteEventStore and RelayError |
| `packages/relay/src/types.ts` | Modified | Added databasePath to RelayConfig interface and DEFAULT_RELAY_CONFIG |
| `packages/relay/src/websocket/NostrRelayServer.test.ts` | Modified | Added 3 integration tests for SqliteEventStore with NostrRelayServer |
| `pnpm-lock.yaml` | Modified | Updated with better-sqlite3 dependencies |

## QA Results

### Review Date: 2026-02-06

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

Excellent implementation. The SqliteEventStore is well-structured with proper separation of concerns, prepared statements for performance, and transaction-based atomicity for replaceable events. Code follows project conventions and is maintainable.

### Refactoring Performed

None required. The implementation is clean and well-organized.

### Compliance Check

- Coding Standards: ✓ PascalCase classes, camelCase functions, UPPER_SNAKE_CASE constants, no `any` usage
- Project Structure: ✓ Co-located test file, exports from index.ts
- Testing Strategy: ✓ 41 tests (38 unit + 3 integration), >80% coverage, factory functions used
- All ACs Met: ✓ All 6 acceptance criteria verified with tests

### Improvements Checklist

- [x] All acceptance criteria have corresponding tests
- [x] Parameterized queries prevent SQL injection
- [x] Proper indexes created for query performance
- [x] Transaction-based atomicity for replaceable events
- [x] Error wrapping in RelayError with STORAGE_ERROR code
- [x] NIP-01 compliant replaceable event logic (kinds 10000-19999)
- [x] Parameterized replaceable events (kinds 30000-39999) with d-tag matching
- [x] Integration tests verify persistence across server restart

### Security Review

No security concerns. Implementation uses parameterized queries via better-sqlite3's prepared statements, preventing SQL injection. Event content is stored as-is per NIP-01 requirements.

### Performance Considerations

Implementation is well-optimized:
- Prepared statements reused for common operations
- Proper indexes on pubkey, kind, created_at, and composite pubkey+kind
- Efficient tag filtering using LIKE patterns (acceptable for MVP per dev notes)

### Files Modified During Review

None. No refactoring was required.

### Gate Status

Gate: PASS → docs/qa/gates/4.2-event-storage-with-sqlite.yml

### Recommended Status

✓ Ready for Done

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-06 | 0.1 | Initial story draft | SM |
| 2026-02-06 | 0.2 | Fixed Dev Notes: corrected EventStore interface to show current state without close(), added current RelayConfig, added created_at comparison to Task 5 for NIP-01 compliance, clarified LIKE-based tag matching in Task 7, added error wrapping guidance to Task 4 | SM |
| 2026-02-06 | 1.0 | Implementation complete: SqliteEventStore with full NIP-01 replaceable event support, 41 new tests, all acceptance criteria met | Dev Agent |
| 2026-02-06 | 1.1 | QA Review: PASS - All acceptance criteria met with comprehensive test coverage | Quinn (QA) |
