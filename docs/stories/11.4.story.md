# Story 11.4: Implement security defense stack — rate limiter, content sanitizer, audit logger

## Status

Done

## Story

**As a** developer building the NIP Handler agent runtime,
**I want** runtime-level security defenses — a per-pubkey/per-kind rate limiter backed by SQLite, a content sanitizer that strips control characters and enforces max lengths on outgoing action content, and an audit logger that records every action decision to SQLite with event metadata and token usage,
**so that** the event processing loop (Story 11.6) can enforce rate limits before calling the LLM, sanitize outgoing content before publishing, and maintain a complete audit trail of all agent decisions.

## Acceptance Criteria

1. A `RateLimiter` class is implemented in `packages/agent/src/rate-limiter.ts` that enforces per-pubkey, per-kind sliding window rate limits
2. Rate limiter uses SQLite (via `better-sqlite3`) for persistence across restarts, with `:memory:` mode for tests
3. Rate limiter exposes `checkLimit(pubkey, kind): { allowed: boolean; reason?: string }` that checks whether a pubkey+kind combination is within its rate limit window
4. Rate limiter exposes `recordAction(pubkey, kind): void` that records an action for rate tracking
5. Rate limits are configurable via a `RateLimiterConfig` with defaults (e.g., max 10 actions per 60 seconds per pubkey+kind)
6. Rate limiter exposes `cleanup(): void` that removes expired entries older than `windowSeconds` to prevent unbounded table growth
7. A `sanitizeActionContent()` function is implemented in `packages/agent/src/content-sanitizer.ts` that strips ASCII control characters (0x00–0x1F except 0x0A newline and 0x0D carriage return) from string fields in action objects
8. Content sanitizer enforces configurable max length on `content`, `result_content`, and `note` fields (default: 4096 characters), truncating if exceeded
9. Content sanitizer returns the sanitized action and a `sanitized: boolean` flag indicating whether any modifications were made
10. An `AuditLogger` class is implemented in `packages/agent/src/audit-log.ts` that records every action decision to SQLite
11. Audit log table stores: `id` (autoincrement), `event_id`, `event_kind`, `event_pubkey`, `action_type`, `action_json`, `input_tokens`, `output_tokens`, `retried`, `rate_limited`, `sanitized`, `created_at` (Unix timestamp)
12. Audit logger exposes `log(entry: AuditEntry): void` (synchronous) and `query(filters: AuditQueryFilters): AuditRecord[]` for retrieval
13. Audit logger supports `:memory:` mode for tests and file-based mode for production
14. Both `RateLimiter` and `AuditLogger` expose `close(): void` to release the SQLite database connection
15. All three components have comprehensive unit tests with >80% coverage
16. `better-sqlite3` is added as a dependency to `packages/agent/package.json`
17. `pnpm build` succeeds across all packages
18. `npx tsc --noEmit` passes from `packages/agent/`
19. `pnpm test` passes with no regressions

## Tasks / Subtasks

- [x] Task 1: Add `better-sqlite3` dependency (AC: 16)
  - **Dependencies:** None (can start immediately)
  - [x] Add `better-sqlite3` `^11.x` to `packages/agent/package.json` `dependencies`
  - [x] Add `@types/better-sqlite3` to `devDependencies`
  - [x] Run `pnpm install` to update lockfile
  - [x] Verify `pnpm build` still succeeds

- [x] Task 2: Implement `RateLimiter` class (AC: 1, 2, 3, 4, 5, 6, 14)
  - **Dependencies:** Task 1 (needs better-sqlite3)
  - [x] Create `packages/agent/src/rate-limiter.ts`
  - [x] Define `RateLimiterConfig` interface:
    ```typescript
    interface RateLimiterConfig {
      dbPath?: string;          // Default: ':memory:'
      maxActions?: number;       // Default: 10
      windowSeconds?: number;    // Default: 60
      nowFn?: () => number;     // Default: () => Math.floor(Date.now() / 1000) — injectable for deterministic tests
    }
    ```
  - [x] Implement `RateLimiter` class:
    - Constructor accepts `RateLimiterConfig`, opens SQLite database, creates schema
    - Schema: `CREATE TABLE IF NOT EXISTS rate_limit_actions (id INTEGER PRIMARY KEY AUTOINCREMENT, pubkey TEXT NOT NULL, kind INTEGER NOT NULL, created_at INTEGER NOT NULL)`
    - Indexes: `CREATE INDEX IF NOT EXISTS idx_rate_pubkey_kind ON rate_limit_actions(pubkey, kind, created_at)`
    - `checkLimit(pubkey: string, kind: number): { allowed: boolean; reason?: string }` — counts actions in the sliding window (`nowFn()` minus `windowSeconds`); returns `allowed: false` with reason if count >= `maxActions`
    - `recordAction(pubkey: string, kind: number): void` — inserts a row with `nowFn()` timestamp
    - `cleanup(): void` — deletes expired entries (older than `windowSeconds`) to prevent unbounded table growth; should be called periodically
    - `close(): void` — closes the SQLite database
  - [x] Use prepared statements for performance (following `packages/bls/src/storage/SqliteEventStore.ts` pattern)
  - [x] Export `RateLimiter`, `RateLimiterConfig` from barrel

- [x] Task 3: Implement `sanitizeActionContent()` (AC: 7, 8, 9)
  - **Dependencies:** None (can start immediately, parallel with Task 2)
  - [x] Create `packages/agent/src/content-sanitizer.ts`
  - [x] Define `ContentSanitizerConfig` interface:
    ```typescript
    interface ContentSanitizerConfig {
      maxContentLength?: number;  // Default: 4096
    }
    ```
  - [x] Define `SanitizeResult<T>` type:
    ```typescript
    interface SanitizeResult<T> {
      action: T;
      sanitized: boolean;
    }
    ```
  - [x] Implement `sanitizeActionContent(action: Action, config?: ContentSanitizerConfig): SanitizeResult<Action>`
    - Strip ASCII control characters (0x00–0x1F) EXCEPT 0x0A (newline) and 0x0D (carriage return) from string fields: `content`, `result_content`, `note`, `comment`, `reason`
    - Use regex: `/[\x00-\x09\x0B\x0C\x0E-\x1F]/g` (preserves \n = 0x0A and \r = 0x0D)
    - Truncate `content`, `result_content`, and `note` fields to `maxContentLength` if they exceed the limit
    - Return the sanitized action and `sanitized: true` if any modification was made
    - For `ActionsResponse` (single or array), sanitize each action in the response
  - [x] Implement `sanitizeActionsResponse(response: ActionsResponse, config?: ContentSanitizerConfig): SanitizeResult<ActionsResponse>`
    - Handles both single action and array response
    - Returns `sanitized: true` if ANY action in the array was modified
  - [x] Export `sanitizeActionContent`, `sanitizeActionsResponse`, `ContentSanitizerConfig`, `SanitizeResult` from barrel

- [x] Task 4: Implement `AuditLogger` class (AC: 10, 11, 12, 13, 14)
  - **Dependencies:** Task 1 (needs better-sqlite3)
  - [x] Create `packages/agent/src/audit-log.ts`
  - [x] Define `AuditEntry` interface:
    ```typescript
    interface AuditEntry {
      eventId: string;
      eventKind: number;
      eventPubkey: string;
      actionType: string;
      actionJson: string;
      inputTokens: number;
      outputTokens: number;
      retried: boolean;
      rateLimited: boolean;
      sanitized: boolean;
    }
    ```
  - [x] Define `AuditRecord` type (extends `AuditEntry` with `id` and `createdAt`):
    ```typescript
    interface AuditRecord extends AuditEntry {
      id: number;
      createdAt: number;
    }
    ```
  - [x] Define `AuditQueryFilters` interface:
    ```typescript
    interface AuditQueryFilters {
      eventId?: string;
      eventKind?: number;
      eventPubkey?: string;
      actionType?: string;
      since?: number;
      until?: number;
      limit?: number;
    }
    ```
  - [x] Implement `AuditLogger` class:
    - Constructor accepts `{ dbPath?: string }` (default: `:memory:`)
    - Schema:
      ```sql
      CREATE TABLE IF NOT EXISTS audit_log (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        event_id TEXT NOT NULL,
        event_kind INTEGER NOT NULL,
        event_pubkey TEXT NOT NULL,
        action_type TEXT NOT NULL,
        action_json TEXT NOT NULL,
        input_tokens INTEGER NOT NULL DEFAULT 0,
        output_tokens INTEGER NOT NULL DEFAULT 0,
        retried INTEGER NOT NULL DEFAULT 0,
        rate_limited INTEGER NOT NULL DEFAULT 0,
        sanitized INTEGER NOT NULL DEFAULT 0,
        created_at INTEGER NOT NULL
      )
      ```
    - Indexes:
      - `CREATE INDEX IF NOT EXISTS idx_audit_event_id ON audit_log(event_id)`
      - `CREATE INDEX IF NOT EXISTS idx_audit_pubkey ON audit_log(event_pubkey)`
      - `CREATE INDEX IF NOT EXISTS idx_audit_kind ON audit_log(event_kind)`
      - `CREATE INDEX IF NOT EXISTS idx_audit_created_at ON audit_log(created_at)`
    - `log(entry: AuditEntry): void` — inserts a row with `created_at = Math.floor(Date.now() / 1000)`
    - `query(filters: AuditQueryFilters): AuditRecord[]` — builds parameterized SQL query from filters, returns matching records
    - `close(): void` — closes the SQLite database
  - [x] Use prepared statements for the `log()` insert (hot path)
  - [x] Export `AuditLogger`, `AuditEntry`, `AuditRecord`, `AuditQueryFilters` from barrel

- [x] Task 5: Write unit tests for `RateLimiter` (AC: 2, 3, 4, 5, 6, 14, 15)
  - **Dependencies:** Task 2
  - [x] Create `packages/agent/src/rate-limiter.test.ts`
  - [x] Test: allows action when under rate limit
  - [x] Test: blocks action when rate limit reached (record N actions, verify N+1 is blocked)
  - [x] Test: rate limit resets after window expires (inject `nowFn` that advances past `windowSeconds`)
  - [x] Test: different pubkeys have independent rate limits
  - [x] Test: different kinds for same pubkey have independent rate limits
  - [x] Test: custom config overrides defaults (maxActions, windowSeconds)
  - [x] Test: `cleanup()` removes expired entries
  - [x] Test: `close()` closes the database without error

- [x] Task 6: Write unit tests for `sanitizeActionContent()` (AC: 7, 8, 9, 15)
  - **Dependencies:** Task 3
  - [x] Create `packages/agent/src/content-sanitizer.test.ts`
  - [x] Test: action without control characters passes through unchanged, `sanitized: false`
  - [x] Test: action with control characters (e.g., `\x00`, `\x1F`) has them stripped, `sanitized: true`
  - [x] Test: newlines and carriage returns are preserved (not stripped)
  - [x] Test: content exceeding max length is truncated, `sanitized: true`
  - [x] Test: content at or below max length is not truncated
  - [x] Test: custom max length config is respected
  - [x] Test: `sanitizeActionsResponse()` handles single action
  - [x] Test: `sanitizeActionsResponse()` handles array of actions, returns `sanitized: true` if any was modified
  - [x] Test: fields without string content (e.g., `react` with `emoji`) are handled correctly
  - [x] Test: `ignore` and `escalate` actions (which have `reason` field) are sanitized

- [x] Task 7: Write unit tests for `AuditLogger` (AC: 10, 11, 12, 13, 14, 15)
  - **Dependencies:** Task 4
  - [x] Create `packages/agent/src/audit-log.test.ts`
  - [x] Test: `log()` inserts a record retrievable by `query()`
  - [x] Test: `query()` with `eventId` filter returns matching records
  - [x] Test: `query()` with `eventKind` filter returns matching records
  - [x] Test: `query()` with `eventPubkey` filter returns matching records
  - [x] Test: `query()` with `actionType` filter returns matching records
  - [x] Test: `query()` with `since` / `until` timestamp range returns matching records
  - [x] Test: `query()` with `limit` returns at most N records
  - [x] Test: `query()` with no filters returns all records (up to default limit)
  - [x] Test: `query()` with multiple filters combines them with AND
  - [x] Test: boolean fields (`retried`, `rateLimited`, `sanitized`) are stored and retrieved correctly
  - [x] Test: `close()` closes the database without error

- [x] Task 8: Update barrel exports and verify build (AC: 17, 18, 19)
  - **Dependencies:** Tasks 2, 3, 4, 5, 6, 7 (final verification step)
  - [x] Update `packages/agent/src/index.ts` to export:
    - `RateLimiter`, `RateLimiterConfig` from `./rate-limiter.js`
    - `sanitizeActionContent`, `sanitizeActionsResponse`, `ContentSanitizerConfig`, `SanitizeResult` from `./content-sanitizer.js`
    - `AuditLogger`, `AuditEntry`, `AuditRecord`, `AuditQueryFilters` from `./audit-log.js`
  - [x] Run `pnpm build` — verify all packages compile
  - [x] Run `npx tsc --noEmit` from `packages/agent/` — verify type-checking passes
  - [x] Run `pnpm test` — verify all tests pass with no regressions

## Dev Notes

### Epic Context
[Source: docs/epics/epic-11-nip-handler-agent-runtime.md]

This is the fourth story of Epic 11 (NIP Handler Agent Runtime). It builds upon the content isolation and allowlist enforcement from Story 11.3 to complete the 10-layer security defense stack. Stories 11.1–11.3 implemented defense layers 1–7 (prompt-level defenses). This story implements layers 8–10 (runtime-level defenses):

- **Layer 8:** Rate limiting — Per-pubkey, per-kind sliding window limits
- **Layer 9:** Content sanitization — Strip control characters, enforce max lengths
- **Layer 10:** Audit logging — Record every action decision to SQLite

These three components are consumed by the event processing loop in Story 11.6, which wires them into the handler pipeline: rate limit check → `handleNostrEvent()` → content sanitization → audit log.

### Previous Story Insights
[Source: docs/stories/11.3.story.md — Dev Agent Record]

- All 7 tasks completed with 17 new tests (1199 total, up from 1182 baseline)
- `packages/agent` builds and type-checks cleanly (`npx tsc --noEmit` passes)
- `pnpm build` succeeds for all packages except pre-existing `packages/core` DTS error (SocialPeerDiscovery `subscribeMany` type mismatch) — not introduced by any Epic 11 story
- `.js` extension required in all ESM relative imports (e.g., `import { ... } from './rate-limiter.js'`)
- `result.usage.inputTokens` and `outputTokens` are `number | undefined` in AI SDK v6.0.86 — used `?? 0` fallback
- Content isolation template implements all 7 prompt-level defense layers from security.md
- Retry logic handles `NoOutputGeneratedError` with single retry + escalation fallback
- Allowlist enforcement validates every action against per-kind allowlists before returning

### Security Reference — Runtime Defense Layers
[Source: .claude/skills/nip-handler/references/security.md]

The security reference defines a 10-layer defense stack. Layers 1–7 (prompt-level) are implemented in Stories 11.2–11.3. This story implements layers 8–10 (runtime-level):

**Layer 8 — Rate limiting:**
> Cap actions per time window per pubkey (e.g., max 10 replies/minute)

Implementation: sliding window using SQLite `rate_limit_actions` table. Count actions where `created_at >= (now - windowSeconds)` for a given pubkey+kind. If count >= maxActions, return `{ allowed: false }`.

**Layer 9 — Content sanitization:**
> Strip control characters from any generated reply content; enforce max lengths

Implementation: regex replacement for ASCII control characters (0x00–0x1F except newline/CR). Truncation for content fields exceeding configurable max length. Applied to outgoing action content before publishing.

**Layer 10 — Audit logging:**
> Log every action decision with event ID, kind, pubkey, and chosen action

Implementation: SQLite `audit_log` table. Synchronous insert per action. Query interface for auditing and debugging.

### SQLite Pattern Reference
[Source: packages/bls/src/storage/SqliteEventStore.ts]

The project uses `better-sqlite3` ^11.x with the following patterns:
- `import Database from 'better-sqlite3'`
- Schema defined as SQL string constants, executed via `db.exec()`
- Prepared statements for hot-path operations: `this.db.prepare('...')`
- Constructor accepts `dbPath` (default `:memory:` for tests)
- `close()` method calls `this.db.close()`
- Error wrapping in custom error classes
- Synchronous API (better-sqlite3 is synchronous, not async)

**Important:** `better-sqlite3` is NOT currently in `packages/agent/package.json` — it must be added as a dependency (Task 1).

### Data Models
[Source: docs/architecture/8-database-schema.md]

The existing database schema doc covers only the events table. This story introduces two new tables:

**`rate_limit_actions` table:**
```sql
CREATE TABLE IF NOT EXISTS rate_limit_actions (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  pubkey TEXT NOT NULL,
  kind INTEGER NOT NULL,
  created_at INTEGER NOT NULL
);
CREATE INDEX IF NOT EXISTS idx_rate_pubkey_kind ON rate_limit_actions(pubkey, kind, created_at);
```

**`audit_log` table:**
```sql
CREATE TABLE IF NOT EXISTS audit_log (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  event_id TEXT NOT NULL,
  event_kind INTEGER NOT NULL,
  event_pubkey TEXT NOT NULL,
  action_type TEXT NOT NULL,
  action_json TEXT NOT NULL,
  input_tokens INTEGER NOT NULL DEFAULT 0,
  output_tokens INTEGER NOT NULL DEFAULT 0,
  retried INTEGER NOT NULL DEFAULT 0,
  rate_limited INTEGER NOT NULL DEFAULT 0,
  sanitized INTEGER NOT NULL DEFAULT 0,
  created_at INTEGER NOT NULL
);
CREATE INDEX IF NOT EXISTS idx_audit_event_id ON audit_log(event_id);
CREATE INDEX IF NOT EXISTS idx_audit_pubkey ON audit_log(event_pubkey);
CREATE INDEX IF NOT EXISTS idx_audit_kind ON audit_log(event_kind);
CREATE INDEX IF NOT EXISTS idx_audit_created_at ON audit_log(created_at);
```

### Existing Components (from Stories 11.1–11.3)
[Source: packages/agent/src/]

| Component | File | Purpose |
|-----------|------|---------|
| `KindRegistry` | `kind-registry.ts` | `resolve(kind)` → handler path or `null` |
| `HandlerLoader` | `handler-loader.ts` | `load(path)` → markdown string (cached) |
| `ActionsResponseSchema` | `schemas/actions.ts` | Zod schema for action validation |
| `ActionSchema` | `schemas/actions.ts` | Zod discriminated union of 11 action types |
| `Action` (type) | `schemas/actions.ts` | TypeScript type inferred from `ActionSchema` |
| `ActionsResponse` (type) | `schemas/actions.ts` | Single action or array of 1–5 actions |
| `validateActionForKind()` | `schemas/allowlists.ts` | Per-kind allowlist enforcement |
| `handleNostrEvent()` | `handler.ts` | Core LLM decision function |
| `buildEventPrompt()` | `prompt-builder.ts` | Content isolation prompt builder |
| `createAgentProviderRegistry()` | `providers.ts` | Multi-model provider registry |

The `Action` type is a discriminated union with these string fields relevant to sanitization:
- `reply`: `content` (required), `reply_to`
- `react`: `emoji`
- `repost`: no string content fields (only `event_id`) — no sanitization needed
- `zap`: `comment` (optional)
- `unwrap`: `note` (optional)
- `fulfill_job`: `result_content` (required)
- `publish_job_feedback`: `content` (required)
- `store`: `note` (optional)
- `forward`: `destination`
- `ignore`: `reason` (required)
- `escalate`: `reason` (required)

### Source Tree (New Files)
[Source: docs/epics/epic-11-nip-handler-agent-runtime.md — Target Architecture]

```
packages/agent/
├── src/
│   ├── index.ts                    # MODIFIED: add new exports
│   ├── rate-limiter.ts             # NEW: Per-pubkey, per-kind rate limiting
│   ├── rate-limiter.test.ts        # NEW: Rate limiter unit tests
│   ├── content-sanitizer.ts        # NEW: Control char stripping, max length enforcement
│   ├── content-sanitizer.test.ts   # NEW: Content sanitizer unit tests
│   ├── audit-log.ts                # NEW: SQLite audit logging
│   ├── audit-log.test.ts           # NEW: Audit logger unit tests
│   ├── providers.ts                # Existing (Story 11.1)
│   ├── kind-registry.ts            # Existing (Story 11.2)
│   ├── handler-loader.ts           # Existing (Story 11.2)
│   ├── handler.ts                  # Existing (Story 11.3) — NOT modified
│   ├── prompt-builder.ts           # Existing (Story 11.3) — NOT modified
│   └── schemas/
│       ├── actions.ts              # Existing (Story 11.2) — NOT modified
│       └── allowlists.ts           # Existing (Story 11.2) — NOT modified
├── handlers/                       # Existing (Story 11.2)
├── package.json                    # MODIFIED: add better-sqlite3
├── tsconfig.json
└── tsup.config.ts
```

### Coding Standards
[Source: docs/architecture/12-coding-standards.md]

- Files: kebab-case for utilities (`rate-limiter.ts`, `content-sanitizer.ts`, `audit-log.ts`)
- Classes: PascalCase (`RateLimiter`, `AuditLogger`)
- Functions: camelCase (`sanitizeActionContent`, `sanitizeActionsResponse`)
- Interfaces: PascalCase (`RateLimiterConfig`, `AuditEntry`, `AuditRecord`)
- All public APIs exported from `index.ts`
- **Use `.js` extension in all relative imports** (ESM requirement)
- Never use `any` — use `unknown` and type guards
- TypeScript ^5.3.x strict mode

### Testing Standards
[Source: docs/architecture/13-test-strategy-and-standards.md]

- **Framework:** Vitest ^1.x
- **File Convention:** `*.test.ts` co-located with source
- **Pattern:** AAA (Arrange, Act, Assert)
- **Mocking:** Use Vitest built-in (`vi.fn()`, `vi.mock()`)
- **Coverage:** >80% for public APIs
- **Test run:** `pnpm test` from workspace root
- **Build validation:** `pnpm build` from workspace root
- **Type-check:** `npx tsc --noEmit` from `packages/agent/`
- **Baseline:** 1199 passed, 0 failures (after Story 11.3)
- **SQLite in tests:** Use `:memory:` mode — no file-based databases in unit tests

### What NOT to Change

- No changes to `packages/core/`, `packages/bls/`, `packages/relay/`, `packages/examples/`, `packages/ui-prototypes/`
- No changes to `docker/`
- No changes to `pnpm-workspace.yaml` or root `vitest.config.ts`
- Do NOT modify `handler.ts`, `prompt-builder.ts`, `schemas/actions.ts`, or `schemas/allowlists.ts` — those are complete from Story 11.3
- Do NOT implement the action executor or event loop — those are Stories 11.5–11.6
- Do NOT wire rate limiter/sanitizer/audit log into `handleNostrEvent()` — the integration is Story 11.6's responsibility
- These are standalone, independently testable components

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5

### Debug Log References
None

### Completion Notes
- All 8 tasks completed successfully
- 59 new tests added (12 RateLimiter + 30 content-sanitizer + 17 audit-log)
- Total test count: 1258 (up from 1199 baseline)
- All acceptance criteria met (ACs 1-19)
- `better-sqlite3` ^11.0.0 added as dependency
- All three security defense components implemented with >80% test coverage
- `packages/agent` builds and type-checks cleanly
- No regressions in existing test suite

### File List

**New Files:**
- `packages/agent/src/rate-limiter.ts` - Per-pubkey/per-kind sliding window rate limiter
- `packages/agent/src/rate-limiter.test.ts` - RateLimiter unit tests (12 tests)
- `packages/agent/src/content-sanitizer.ts` - Control char stripping and max length enforcement
- `packages/agent/src/content-sanitizer.test.ts` - Content sanitizer unit tests (30 tests)
- `packages/agent/src/audit-log.ts` - SQLite-backed audit trail
- `packages/agent/src/audit-log.test.ts` - AuditLogger unit tests (17 tests)

**Modified Files:**
- `packages/agent/package.json` - Added `better-sqlite3` and `@types/better-sqlite3`
- `packages/agent/src/index.ts` - Added exports for all three security components
- `pnpm-lock.yaml` - Updated with new dependencies

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-17 | 0.1 | Initial story draft | SM (Claude Opus 4.6) |
| 2026-02-17 | 0.2 | Validation fixes: add ACs for `cleanup()` and `close()` (AC 6, 14); renumber ACs 7–19; add `nowFn` to `RateLimiterConfig` for deterministic tests; add `repost` to action field list; update all task AC references; fix epic table description to reflect actual 11.3/11.4 scope split | SM (Claude Opus 4.6) |

## QA Results

### Review Date: 2026-02-17

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

Excellent implementation of the three runtime security defense components (layers 8-10). The code demonstrates strong architectural design, proper use of SQLite patterns, comprehensive test coverage, and adherence to all project standards.

**Strengths:**
- Clean, well-documented TypeScript with proper type safety (no `any` types)
- Prepared statements used correctly for all hot-path operations
- Proper database indexing strategy for optimal query performance
- Discriminated unions for type-safe action handling in content sanitizer
- Injectable dependencies (`nowFn`) enable deterministic testing
- Comprehensive edge case coverage in all test suites
- Proper resource lifecycle management (`close()` methods)

**Architecture:**
All three components are standalone, independently testable, and properly decoupled from the handler pipeline (integration deferred to Story 11.6 as intended). The SQLite patterns follow the established `SqliteEventStore` precedent from `packages/bls`.

### Refactoring Performed

No refactoring was necessary. The implementation is clean, well-structured, and follows all coding standards.

### Compliance Check

- Coding Standards: ✓ Full compliance
  - Proper naming conventions (PascalCase classes, camelCase functions, kebab-case files)
  - ESM imports with `.js` extensions throughout
  - No `any` types used (strict TypeScript)
  - All public APIs exported from `index.ts`
- Project Structure: ✓ Full compliance
  - Test files co-located with source (`.test.ts` convention)
  - Proper package organization in `packages/agent/src/`
- Testing Strategy: ✓ Full compliance
  - Vitest framework with AAA pattern
  - >80% coverage achieved (59 comprehensive tests)
  - `:memory:` SQLite mode for unit tests
  - No live dependencies in tests
- All ACs Met: ✓ All 19 acceptance criteria fully satisfied

### Improvements Checklist

All items addressed by the developer. No outstanding issues.

- [x] RateLimiter implements sliding window rate limiting with SQLite persistence (AC 1-6, 14)
- [x] Content sanitizer strips control chars and enforces max lengths (AC 7-9)
- [x] AuditLogger records complete audit trail to SQLite (AC 10-14)
- [x] better-sqlite3 dependency added (AC 16)
- [x] All barrel exports updated (AC 17-19)
- [x] 59 comprehensive tests added (12 + 30 + 17)
- [x] pnpm build succeeds
- [x] npx tsc --noEmit passes
- [x] All tests pass (1258 total, up from 1199 baseline)

### Security Review

**Defense Layers Implemented (8-10):**

**Layer 8 - Rate Limiting:**
- ✓ Per-pubkey, per-kind sliding window implementation
- ✓ SQLite persistence prevents restart bypass
- ✓ Configurable limits with sensible defaults (10 actions/60s)
- ✓ `cleanup()` method prevents unbounded table growth
- ✓ Injectable `nowFn` enables time-travel testing

**Layer 9 - Content Sanitization:**
- ✓ ASCII control character stripping (0x00-0x1F except \n, \r)
- ✓ Max length enforcement on content/result_content/note (4096 default)
- ✓ All 11 action types handled correctly
- ✓ Preserves newlines and carriage returns
- ✓ Returns sanitization flag for audit logging

**Layer 10 - Audit Logging:**
- ✓ Complete audit trail with event metadata
- ✓ Token usage tracking (input/output)
- ✓ Security flags (retried, rate_limited, sanitized)
- ✓ Comprehensive query interface with filters
- ✓ Proper indexing for efficient queries

**Security Concerns:** None identified. The implementation follows defense-in-depth principles and integrates well with the existing security architecture (layers 1-7 from Stories 11.2-11.3).

### Performance Considerations

**Optimizations Present:**
- Prepared statements for all hot-path operations (rate limit check, action recording, audit logging)
- Proper database indexing on frequently queried columns
- Synchronous SQLite operations (better-sqlite3 is faster than async alternatives)

**Potential Future Enhancements (Not Required):**
- Batch audit logging for high-throughput scenarios
- Periodic cleanup job for rate limiter (currently manual)
- Connection pooling for file-based databases (not needed for :memory: mode)

No performance issues identified for the expected usage patterns.

### Files Modified During Review

None. No modifications were necessary.

### Requirements Traceability

All 19 acceptance criteria have corresponding test coverage:

**AC 1-6, 14 (RateLimiter):**
- Given: A pubkey and kind under rate limit
- When: checkLimit() is called
- Then: Action is allowed
- Tests: "allows action when under rate limit", "blocks action when rate limit reached", "rate limit resets after window expires", "different pubkeys have independent rate limits", "different kinds for same pubkey have independent rate limits", "custom config overrides defaults", "cleanup() removes expired entries", "close() closes the database without error"

**AC 7-9 (Content Sanitizer):**
- Given: An action with control characters or excessive length
- When: sanitizeActionContent() is called
- Then: Control chars are stripped, length is enforced, sanitized flag is set
- Tests: 30 tests covering all action types, control char stripping, max length truncation, newline preservation, array handling

**AC 10-14 (AuditLogger):**
- Given: An audit entry with event metadata and security flags
- When: log() is called
- Then: Entry is stored in SQLite and retrievable via query()
- Tests: 17 tests covering log/query operations, all filter types, boolean field handling, ordering, timestamps, lifecycle

**AC 15 (Test Coverage):**
- 59 tests total (12 + 30 + 17) with comprehensive edge case coverage
- All public APIs tested with AAA pattern
- >80% coverage achieved

**AC 16-19 (Build Verification):**
- better-sqlite3 ^11.0.0 added to dependencies ✓
- @types/better-sqlite3 added to devDependencies ✓
- pnpm build succeeds ✓
- npx tsc --noEmit passes ✓
- pnpm test passes with 1258 tests (59 new, 0 regressions) ✓

### Gate Status

Gate: PASS → docs/qa/gates/11.4-security-defense-stack.yml
Quality score: 100

### Recommended Status

✓ Ready for Done

All acceptance criteria met, comprehensive test coverage, clean implementation, no issues identified.
