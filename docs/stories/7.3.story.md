# Story 7.3: Implement Settlement Negotiation in SPSP Server

## Status

Done

## Story

**As a** peer receiving an SPSP request,
**I want** to negotiate the best matching settlement chain, request a payment channel via the connector Admin API, and return the channel details in my SPSP response,
**so that** the ILP FULFILL proves the payment channel is live and ready for claim exchange.

## Acceptance Criteria

1. Chain matching logic implemented: intersection of supportedChains arrays
2. Preference order: requester's preferredTokens → responder's preferredTokens → first match
3. Channel opened via `POST /admin/channels` on connector (not via direct SDK call)
4. BLS verifies channel state via `GET /admin/channels/:channelId` before returning FULFILL
5. Channel opening is **synchronous** — SPSP response only sent after connector confirms channel is open
6. `channelId` included in SpspResponse when channel successfully opened
7. Graceful degradation: when no chain intersection, return basic SPSP response without settlement fields (Note: ILP REJECT with `invalid_request` is a BLS-layer integration concern, not implemented in this core library story)
8. Graceful degradation: when connector returns channel opening failure, return basic SPSP response without settlement fields (Note: ILP REJECT with `internal_error` is a BLS-layer integration concern, not implemented in this core library story)
9. Graceful degradation: when channel opening exceeds timeout, return basic SPSP response without settlement fields (Note: ILP REJECT with T00 tied to packet expiresAt is a BLS-layer integration concern, not implemented in this core library story)
10. Configurable `initialDeposit`, `settlementTimeout`, and `channelOpenTimeout` via `SettlementNegotiationConfig` (Note: env var reading is a BLS-layer concern; the core library accepts config objects)
11. No blockchain SDK imports in BLS code — all chain operations via connector Admin API
12. Unit tests with mocked connector Admin API (integration test with real connector + Anvil deferred to a separate integration test story)

## Tasks / Subtasks

- [x] Task 1: Define `ConnectorChannelClient` interface in `types.ts` (AC: 3, 4, 11)
  - [x] Add `ConnectorChannelClient` interface with the following methods:
    - `openChannel(params: OpenChannelParams): Promise<OpenChannelResult>` — calls `POST /admin/channels` on the connector
    - `getChannelState(channelId: string): Promise<ChannelState>` — calls `GET /admin/channels/:channelId` on the connector
  - [x] Add `OpenChannelParams` interface: `{ peerId: string; chain: string; token?: string; tokenNetwork?: string; peerAddress: string; initialDeposit?: string; settlementTimeout?: number }`
  - [x] Add `OpenChannelResult` interface: `{ channelId: string; status: string }`
  - [x] Add `ChannelState` interface: `{ channelId: string; status: 'opening' | 'open' | 'closed' | 'settled'; chain: string }`
  - [x] Export new types from `types.ts` (they are already auto-exported via `export type { ... } from './types.js'` in `index.ts` — add them to the export list)

- [x] Task 2: Define `SettlementNegotiationConfig` interface in `types.ts` (AC: 10)
  - [x] Add `SettlementNegotiationConfig` interface: `{ ownSupportedChains: string[]; ownSettlementAddresses: Record<string, string>; ownPreferredTokens?: Record<string, string>; ownTokenNetworks?: Record<string, string>; initialDeposit?: string; settlementTimeout?: number; channelOpenTimeout?: number }`
  - [x] `ownSupportedChains` — chains the server supports (from own `IlpPeerInfo`)
  - [x] `ownSettlementAddresses` — server's settlement addresses by chain
  - [x] `ownPreferredTokens` — server's preferred token addresses by chain (optional)
  - [x] `ownTokenNetworks` — server's TokenNetwork contract addresses by chain (optional, EVM only)
  - [x] `initialDeposit` — configurable initial deposit amount (default: `"0"`)
  - [x] `settlementTimeout` — configurable challenge period in seconds (default: `86400`)
  - [x] `channelOpenTimeout` — max time in ms to wait for channel to become open (default: `30000`)
  - [x] Export from `types.ts` and add to `index.ts` export list

- [x] Task 3: Implement `negotiateSettlementChain()` pure function in new file `packages/core/src/spsp/settlement.ts` (AC: 1, 2, 7)
  - [x] Create `packages/core/src/spsp/settlement.ts`
  - [x] Implement `negotiateSettlementChain(requesterChains: string[], responderChains: string[], requesterPreferredTokens?: Record<string, string>, responderPreferredTokens?: Record<string, string>): string | null`
  - [x] Step 1: Compute intersection of `requesterChains` and `responderChains`
  - [x] Step 2: If intersection is empty, return `null` (no match)
  - [x] Step 3: Preference order — iterate the intersection:
    - First, check if any chain in the intersection has a matching token in `requesterPreferredTokens` — prefer that chain
    - If no requester preference match, check `responderPreferredTokens` — prefer that chain
    - If no preferred token match at all, return the first chain in the intersection (order from requester's list preserved)
  - [x] Export from `packages/core/src/spsp/index.ts`
  - [x] Export from `packages/core/src/index.ts`

- [x] Task 4: Implement `resolveTokenForChain()` helper in `settlement.ts` (AC: 2)
  - [x] Implement `resolveTokenForChain(chain: string, requesterPreferredTokens?: Record<string, string>, responderPreferredTokens?: Record<string, string>): string | undefined`
  - [x] If `requesterPreferredTokens` has an entry for `chain`, return it
  - [x] Else if `responderPreferredTokens` has an entry for `chain`, return it
  - [x] Else return `undefined`
  - [x] Export from `packages/core/src/spsp/index.ts` and `packages/core/src/index.ts`

- [x] Task 5: Update `NostrSpspServer` constructor to accept optional settlement config and channel client (AC: 3, 10, 11)
  - [x] Add optional `settlementConfig?: SettlementNegotiationConfig` parameter to constructor
  - [x] Add optional `channelClient?: ConnectorChannelClient` parameter to constructor
  - [x] Store both as private readonly fields
  - [x] Settlement negotiation only occurs when BOTH `settlementConfig` and `channelClient` are provided
  - [x] When neither is provided, behavior is identical to current (backward compat)

- [x] Task 6: Update `NostrSpspServer.processRequest()` to perform settlement negotiation (AC: 1, 2, 3, 4, 5, 6, 7, 8, 9)
  - [x] After parsing the SPSP request and calling the generator, check if settlement negotiation is enabled (both `settlementConfig` and `channelClient` are set)
  - [x] If enabled and the parsed request contains `supportedChains`:
    - Call `negotiateSettlementChain()` with request's `supportedChains` and config's `ownSupportedChains`, and both parties' `preferredTokens`
    - If result is `null` (no chain intersection): log warning and fall through to basic SPSP response without settlement (graceful degradation per AC: 7 — note: ILP REJECT for "no intersection" is an integration concern handled at the BLS layer, not in the core library; the SPSP server returns a basic response)
    - If match found:
      1. Resolve token via `resolveTokenForChain()` using both parties' preferred tokens
      2. Resolve `peerAddress` from `request.settlementAddresses?.[negotiatedChain]` — if `undefined` (requester did not provide a settlement address for the negotiated chain), log warning and fall through to basic SPSP response without settlement (graceful degradation — cannot open a channel without the peer's address)
      3. Derive `peerId` from sender pubkey: `nostr-${senderPubkey.slice(0, 16)}`
      4. Call `channelClient.openChannel()` with `{ peerId, chain: negotiatedChain, token, tokenNetwork: ownTokenNetworks[negotiatedChain], peerAddress, initialDeposit: config.initialDeposit ?? '0', settlementTimeout: config.settlementTimeout ?? 86400 }`
      5. Poll `channelClient.getChannelState(channelId)` until `status === 'open'` or timeout (AC: 4, 5)
        - Poll interval: 1000ms
        - Max wait: `config.channelOpenTimeout ?? 30000` ms
        - If timeout: log error and fall through to basic SPSP response (graceful degradation)
      6. On success, add settlement fields to `SpspResponse`: `negotiatedChain`, `settlementAddress: ownSettlementAddresses[negotiatedChain]`, `tokenAddress: resolvedToken`, `tokenNetworkAddress: ownTokenNetworks?.[negotiatedChain]`, `channelId`, `settlementTimeout: config.settlementTimeout ?? 86400`
    - If `channelClient.openChannel()` throws: log error and fall through to basic SPSP response (graceful degradation per AC: 8 — note: ILP REJECT for "channel failure" is an integration concern at the BLS layer)
  - [x] If settlement not enabled or request has no `supportedChains`, proceed with basic SPSP response (current behavior)

- [x] Task 7: Write unit tests for `negotiateSettlementChain()` (AC: 1, 2)
  - [x] Create `packages/core/src/spsp/settlement.test.ts`
  - [x] Test: returns first matching chain when both peers support multiple chains
  - [x] Test: returns `null` when no chain intersection
  - [x] Test: prefers chain with requester's preferred token when available
  - [x] Test: prefers chain with responder's preferred token when no requester preference
  - [x] Test: falls back to first intersection match when no token preferences
  - [x] Test: handles empty requester chains (returns null)
  - [x] Test: handles empty responder chains (returns null)
  - [x] Test: preserves requester's chain order for intersection

- [x] Task 8: Write unit tests for `resolveTokenForChain()` (AC: 2)
  - [x] Add to `settlement.test.ts`
  - [x] Test: returns requester's preferred token when available
  - [x] Test: returns responder's preferred token when requester has none
  - [x] Test: returns undefined when neither has a preference for the chain
  - [x] Test: requester preference takes priority over responder's

- [x] Task 9: Write unit tests for `NostrSpspServer` with settlement negotiation (AC: 1, 3, 4, 5, 6, 10)
  - [x] Add tests in `packages/core/src/spsp/NostrSpspServer.test.ts`
  - [x] Test: when settlement enabled and chains match, response includes `negotiatedChain`, `settlementAddress`, `channelId`
  - [x] Test: when settlement enabled and chains match, `channelClient.openChannel()` is called with correct params
  - [x] Test: when settlement enabled and channel opens successfully, `channelClient.getChannelState()` is called to verify
  - [x] Test: response includes `tokenAddress` and `tokenNetworkAddress` when EVM chain is negotiated
  - [x] Test: response includes `settlementTimeout` from config
  - [x] Test: backward compat — when no `settlementConfig` or `channelClient`, behavior unchanged (basic SPSP response)
  - [x] Test: backward compat — when request has no `supportedChains`, behavior unchanged

- [x] Task 10: Write unit tests for `NostrSpspServer` settlement error handling (AC: 7, 8, 9)
  - [x] Add tests in `packages/core/src/spsp/NostrSpspServer.test.ts`
  - [x] Test: when no chain intersection, returns basic SPSP response without settlement fields (graceful degradation)
  - [x] Test: when requester has no `settlementAddresses` entry for the negotiated chain, returns basic SPSP response without settlement fields (graceful degradation — missing peerAddress)
  - [x] Test: when `channelClient.openChannel()` throws, returns basic SPSP response without settlement fields (graceful degradation)
  - [x] Test: when channel state polling times out (never reaches `open`), returns basic SPSP response without settlement fields
  - [x] Test: when `channelClient.getChannelState()` throws during polling, returns basic SPSP response
  - [x] Test: server continues processing subsequent requests after a settlement failure

- [x] Task 11: Update `NostrSpspClient.requestSpspInfo()` to pass settlement info (AC: 1, 2)
  - [x] Add optional `settlementInfo?: SpspRequestSettlementInfo` parameter to `requestSpspInfo()` options
  - [x] Pass `settlementInfo` to `buildSpspRequestEvent()` as the third argument
  - [x] When settlement fields are in the response, include them in the returned result (extend return type or add settlement fields to result)
  - [x] Add `SettlementNegotiationResult` type for the settlement portion of the response: `{ negotiatedChain: string; settlementAddress: string; tokenAddress?: string; tokenNetworkAddress?: string; channelId?: string; settlementTimeout?: number }`
  - [x] Extend `requestSpspInfo()` return type to `Promise<SpspInfo & { settlement?: SettlementNegotiationResult }>`
  - [x] When response has `negotiatedChain`, populate `settlement` field in result

- [x] Task 12: Write unit tests for `NostrSpspClient` with settlement info (AC: 1, 2)
  - [x] Add tests in `packages/core/src/spsp/NostrSpspClient.test.ts`
  - [x] Test: `requestSpspInfo` with `settlementInfo` passes settlement data to `buildSpspRequestEvent`
  - [x] Test: when response includes settlement fields, returned result has `settlement` object
  - [x] Test: backward compat — when no `settlementInfo`, request has no settlement fields
  - [x] Test: backward compat — when response has no settlement fields, result has no `settlement` field

- [x] Task 13: Verify all new types and functions are exported from package (AC: 11)
  - **Note:** This is a verification step — exports should already be added as part of Tasks 1–4. Verify completeness before running tests.
  - [x] Verify `ConnectorChannelClient`, `OpenChannelParams`, `OpenChannelResult`, `ChannelState`, `SettlementNegotiationConfig`, `SettlementNegotiationResult` are exported from `packages/core/src/index.ts`
  - [x] Verify `negotiateSettlementChain`, `resolveTokenForChain` are exported from `packages/core/src/spsp/index.ts` and `packages/core/src/index.ts`
  - [x] Fix any missing exports discovered during verification

- [x] Task 14: Run full test suite and lint (AC: 12)
  - [x] Run `pnpm test` — all existing tests must pass plus new tests
  - [x] Run `pnpm lint` — no new lint errors
  - [x] Verify no regressions in existing `NostrSpspClient.test.ts` tests
  - [x] Verify no regressions in existing `NostrSpspServer.test.ts` tests
  - [x] Verify no regressions in existing `builders.test.ts` and `parsers.test.ts` tests

## Dev Notes

### Previous Story Insights
[Source: docs/stories/7.2.story.md#dev-agent-record]

From Story 7.2 (Extend SPSP Request/Response with Settlement Negotiation):
- 890 tests passing (27 new tests added), 0 failures
- ESLint: 3 pre-existing errors (none introduced by Story 7.2) — same as Story 7.1
- DTS build has a pre-existing error in `SocialPeerDiscovery.ts` (not related to this story)
- `SpspRequestSettlementInfo` interface is exported from `builders.ts`, `events/index.ts`, and package root `index.ts` — use it in this story when the client passes settlement preferences
- `buildSpspRequestEvent` now accepts an optional third parameter `settlementInfo?: SpspRequestSettlementInfo` — the client needs to pass this
- `buildSpspResponseEvent` accepts `SpspResponse` which now has optional settlement fields (`negotiatedChain`, `settlementAddress`, `tokenAddress`, `tokenNetworkAddress`, `channelId`, `settlementTimeout`) — the server populates these when settlement negotiation succeeds
- All SPSP parsers (`parseSpspRequest`, `parseSpspResponse`) already validate the new settlement fields with `validateChainId()` and `InvalidEventError`
- Backward compatibility is fully maintained: requests/responses without settlement fields parse correctly with all new fields `undefined`

### Data Models
[Source: packages/core/src/types.ts]

**Current `SpspRequest` interface (with settlement fields from Story 7.2):**
```typescript
export interface SpspRequest {
  requestId: string;
  timestamp: number;
  ilpAddress?: string;
  supportedChains?: string[];
  settlementAddresses?: Record<string, string>;
  preferredTokens?: Record<string, string>;
}
```

**Current `SpspResponse` interface (with settlement fields from Story 7.2):**
```typescript
export interface SpspResponse {
  requestId: string;
  destinationAccount: string;
  sharedSecret: string;
  negotiatedChain?: string;
  settlementAddress?: string;
  tokenAddress?: string;
  tokenNetworkAddress?: string;
  channelId?: string;
  settlementTimeout?: number;
}
```

**Current `IlpPeerInfo` interface (with settlement fields from Story 7.1):**
```typescript
export interface IlpPeerInfo {
  ilpAddress: string;
  btpEndpoint: string;
  /** @deprecated */
  settlementEngine?: string;
  assetCode: string;
  assetScale: number;
  supportedChains?: string[];
  settlementAddresses?: Record<string, string>;
  preferredTokens?: Record<string, string>;
  tokenNetworks?: Record<string, string>;
}
```

**New types to add in this story:**
```typescript
export interface OpenChannelParams {
  peerId: string;
  chain: string;
  token?: string;
  tokenNetwork?: string;
  peerAddress: string;
  initialDeposit?: string;
  settlementTimeout?: number;
}

export interface OpenChannelResult {
  channelId: string;
  status: string;
}

export interface ChannelState {
  channelId: string;
  status: 'opening' | 'open' | 'closed' | 'settled';
  chain: string;
}

export interface ConnectorChannelClient {
  openChannel(params: OpenChannelParams): Promise<OpenChannelResult>;
  getChannelState(channelId: string): Promise<ChannelState>;
}

export interface SettlementNegotiationConfig {
  ownSupportedChains: string[];
  ownSettlementAddresses: Record<string, string>;
  ownPreferredTokens?: Record<string, string>;
  ownTokenNetworks?: Record<string, string>;
  initialDeposit?: string;
  settlementTimeout?: number;
  channelOpenTimeout?: number;
}

export interface SettlementNegotiationResult {
  negotiatedChain: string;
  settlementAddress: string;
  tokenAddress?: string;
  tokenNetworkAddress?: string;
  channelId?: string;
  settlementTimeout?: number;
}
```

[Source: docs/epics/epic-7-spsp-settlement-negotiation.md#story-73]
[Source: docs/architecture/payment-channel-reference.md#admin-api-reference]

**Chain Identifier Format (from Story 7.1):**
- Pattern: `{blockchain}:{network}` or `{blockchain}:{network}:{chainId}`
- EVM: `evm:base:8453`, XRP: `xrp:mainnet`, Aptos: `aptos:mainnet:1`
- Validated by `validateChainId()` from `parsers.ts`
[Source: packages/core/src/events/parsers.ts#validateChainId]

### API Specifications

**Connector Admin API (called by BLS, not by this core library directly):**

The `ConnectorChannelClient` interface abstracts the connector's Admin API for channel operations. In production, the BLS implements this interface with HTTP calls to the connector. In tests, it is mocked.

Reference endpoints (from connector Admin API):
- `POST /admin/channels` — open a channel: `{ peerId, chain, token, tokenNetwork, initialDeposit, settlementTimeout }` → `{ channelId, status }`
- `GET /admin/channels/:channelId` — get channel state: → `{ channelId, status, chain }`
- `POST /admin/peers` — register peer (existing from `ConnectorAdminClient` in `bootstrap.ts`)

Note: `POST /admin/channels` and `GET /admin/channels/:channelId` are provided by agent-runtime Epic 21. This story defines the TypeScript interface; the actual HTTP implementation lives in the BLS (out of scope for this library story).
[Source: docs/architecture/payment-channel-reference.md#admin-api-reference]
[Source: docs/epics/epic-7-spsp-settlement-negotiation.md#story-73]

### Component Specifications

**`NostrSpspServer` (`packages/core/src/spsp/NostrSpspServer.ts`):**
- Currently: constructor accepts `(relayUrls, secretKey, pool?)`, `handleSpspRequests(generator)` subscribes to kind:23194 and responds with basic SPSP
- After this story: constructor also accepts optional `settlementConfig` and `channelClient`
- `processRequest()` gains settlement negotiation logic between parsing the request and building the response
- When settlement negotiation succeeds, the `SpspResponse` object includes `negotiatedChain`, `settlementAddress`, `tokenAddress`, `tokenNetworkAddress`, `channelId`, `settlementTimeout`
- When settlement fails or is not enabled, behavior is identical to current (basic SPSP response with no settlement fields)
[Source: packages/core/src/spsp/NostrSpspServer.ts]

**`NostrSpspClient` (`packages/core/src/spsp/NostrSpspClient.ts`):**
- Currently: `requestSpspInfo(recipientPubkey, options?)` sends basic SPSP request
- After this story: `options` gains optional `settlementInfo` field, passed to `buildSpspRequestEvent` as third argument
- Return type extended to include optional `settlement` field when response contains settlement data
- Existing behavior preserved when no `settlementInfo` provided
[Source: packages/core/src/spsp/NostrSpspClient.ts]

**New file: `packages/core/src/spsp/settlement.ts`**
- Pure functions for settlement chain negotiation (no I/O, no side effects)
- `negotiateSettlementChain()` — intersect chains, apply preference order
- `resolveTokenForChain()` — determine which token to use for a chain
[Source: docs/architecture/9-source-tree.md]

### File Locations
[Source: docs/architecture/9-source-tree.md, packages/core/src/]

Files to create:
- `packages/core/src/spsp/settlement.ts` — Pure settlement negotiation functions
- `packages/core/src/spsp/settlement.test.ts` — Tests for settlement negotiation functions

Files to modify:
- `packages/core/src/types.ts` — Add `ConnectorChannelClient`, `OpenChannelParams`, `OpenChannelResult`, `ChannelState`, `SettlementNegotiationConfig`, `SettlementNegotiationResult` interfaces
- `packages/core/src/spsp/NostrSpspServer.ts` — Add settlement config + channel client to constructor, add settlement negotiation to `processRequest()`
- `packages/core/src/spsp/NostrSpspServer.test.ts` — Add settlement negotiation tests (happy path, error handling, backward compat)
- `packages/core/src/spsp/NostrSpspClient.ts` — Add `settlementInfo` to `requestSpspInfo` options, extend return type
- `packages/core/src/spsp/NostrSpspClient.test.ts` — Add tests for settlement info passing and settlement result parsing
- `packages/core/src/spsp/index.ts` — Export `negotiateSettlementChain`, `resolveTokenForChain`
- `packages/core/src/index.ts` — Export new types and settlement functions

Files NOT modified:
- `packages/core/src/events/builders.ts` — No changes (already supports settlement fields from Story 7.2)
- `packages/core/src/events/parsers.ts` — No changes (already validates settlement fields from Story 7.2)
- `packages/core/src/events/index.ts` — No changes
- `packages/core/src/constants.ts` — No new event kinds
- `packages/core/src/errors.ts` — No new error classes needed (graceful degradation via fallback, not exception)
- `packages/core/src/bootstrap.ts` — Not modified (existing `ConnectorAdminClient` is separate from `ConnectorChannelClient`)

### Technical Constraints

**Architectural boundary (CRITICAL):**
The BLS does NOT directly import or call any blockchain SDK. All on-chain operations are delegated to the connector via the `ConnectorChannelClient` interface. The core library defines the interface; the BLS provides the implementation (HTTP client to connector Admin API). This story only defines the interface and the negotiation logic.
[Source: docs/epics/epic-7-spsp-settlement-negotiation.md#architectural-boundary]

**Graceful degradation pattern:**
When settlement negotiation fails at any stage (no chain match, channel open failure, polling timeout), the server falls back to a basic SPSP response without settlement fields. This ensures the SPSP handshake still succeeds for basic payment setup even when settlement negotiation fails. The ILP REJECT behavior described in AC 7/8/9 is an integration concern at the BLS layer — the core library's SPSP server uses graceful degradation.
[Source: docs/epics/epic-7-spsp-settlement-negotiation.md#story-73]

**Channel state polling:**
After calling `openChannel()`, the server polls `getChannelState()` until `status === 'open'`. This is necessary because channel opening is asynchronous on-chain — the connector returns immediately with `{ channelId, status: 'opening' }` and the channel transitions to `'open'` once the on-chain transaction confirms. The polling interval (1s) and max timeout (configurable, default 30s) ensure the SPSP response is only sent once the channel is confirmed live.
[Source: docs/architecture/payment-channel-reference.md#opening-a-channel]

**PeerId derivation:**
The connector identifies peers by a string ID. The convention established in `bootstrap.ts` is `nostr-${pubkey.slice(0, 16)}` — use the same convention here for consistency.
[Source: packages/core/src/bootstrap.ts:256]

**NIP-44 encryption:**
All SPSP payloads (including settlement fields) are NIP-44 encrypted. The builders and parsers already handle this. This story only needs to populate the settlement fields in the `SpspResponse` object before passing it to `buildSpspResponseEvent()`.
[Source: packages/core/src/events/builders.ts]

### Scope Boundaries

**In Scope:**
- `ConnectorChannelClient` interface definition (TypeScript interface only — no HTTP implementation)
- `SettlementNegotiationConfig` for server configuration
- Pure chain negotiation logic (`negotiateSettlementChain`, `resolveTokenForChain`)
- `NostrSpspServer` updated to negotiate settlement and open channels when configured
- `NostrSpspClient` updated to pass settlement preferences and return settlement results
- Polling logic for channel state verification
- Graceful degradation when settlement negotiation fails
- Unit tests for all new logic with mocked `ConnectorChannelClient`

**Out of Scope:**
- HTTP implementation of `ConnectorChannelClient` (lives in BLS package, not core library)
- BLS-level ILP REJECT handling (AC 7, 8, 9 describe BLS integration behavior — the core library uses graceful degradation)
- Integration test with real connector + Anvil (AC 12 — deferred to integration test story or manual testing)
- Opening payment channels (the actual on-chain operation is inside the connector — this story calls the interface)
- Modifying the connector's Admin API (that's agent-runtime Epic 21)
- BLS pricing changes (Story 7.4 — configurable 0-amount SPSP)
- Channel deposit, close, or lifecycle management beyond initial opening

### Error Handling
[Source: docs/architecture/11-error-handling-strategy.md, packages/core/src/errors.ts]

- Settlement negotiation errors are handled via graceful degradation (fallback to basic SPSP), NOT via exception throwing
- If `openChannel()` throws: catch, log warning, return basic SPSP response
- If polling `getChannelState()` times out or throws: catch, log warning, return basic SPSP response
- If no chain intersection: log info, return basic SPSP response
- If requester has no `settlementAddresses` entry for the negotiated chain (missing `peerAddress`): log warning, return basic SPSP response
- Existing error handling in `processRequest()` (parse errors, generator errors, publish errors) is unchanged
- No new error classes needed — the server's existing try/catch pattern in `processRequest()` covers the new code paths

### Testing

**Test Framework:** Vitest 1.x
[Source: docs/architecture/13-test-strategy-and-standards.md]

**Test Standards:**
- Co-located test files: `settlement.test.ts` alongside `settlement.ts`, additional tests in existing `NostrSpspServer.test.ts` and `NostrSpspClient.test.ts`
- Follow AAA pattern (Arrange, Act, Assert) — same as existing tests
- Use `generateSecretKey()` and `getPublicKey()` from `nostr-tools/pure` for test key generation
- Mock `ConnectorChannelClient` with Vitest `vi.fn()` for all channel operations
- Mock `SimplePool` for relay operations (already established pattern in existing tests)
- Coverage: >80% for new negotiation and server update code

**Mock patterns:**
```typescript
const mockChannelClient: ConnectorChannelClient = {
  openChannel: vi.fn().mockResolvedValue({ channelId: '0xCHANNEL123', status: 'opening' }),
  getChannelState: vi.fn().mockResolvedValue({ channelId: '0xCHANNEL123', status: 'open', chain: 'evm:base:8453' }),
};
```

**Test fixtures:**
```typescript
const testSettlementConfig: SettlementNegotiationConfig = {
  ownSupportedChains: ['evm:base:8453', 'xrp:mainnet'],
  ownSettlementAddresses: { 'evm:base:8453': '0xSERVER_ADDRESS', 'xrp:mainnet': 'rSERVER_ADDRESS' },
  ownPreferredTokens: { 'evm:base:8453': '0xAGENT_TOKEN' },
  ownTokenNetworks: { 'evm:base:8453': '0xTOKEN_NETWORK' },
  initialDeposit: '1000000',
  settlementTimeout: 86400,
  channelOpenTimeout: 5000, // short timeout for tests
};
```

**Existing test fixtures (do NOT modify — existing tests depend on them):**
- `createMockSpspRequestEvent()` in `NostrSpspServer.test.ts` — creates basic request without settlement fields
- `MOCK_SPSP_INFO` in `NostrSpspServer.test.ts` — basic SpspInfo fixture
- `createEncryptedResponseEvent()` in `NostrSpspClient.test.ts` — creates response for round-trip tests

**Test count expectation:** ~25-30 new tests across `settlement.test.ts` (~10), `NostrSpspServer.test.ts` (~10-12), `NostrSpspClient.test.ts` (~5-6)

## QA Results

### Review Date: 2026-02-08

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

Excellent implementation quality. The story is well-executed with clean separation of concerns:

- **`settlement.ts`** contains pure functions with no I/O — ideal for unit testing and reuse. The `negotiateSettlementChain()` algorithm is clear and correct: Set-based intersection preserving requester order, then preference layering.
- **`NostrSpspServer.ts`** cleanly separates settlement negotiation into a private `negotiateSettlement()` method that mutates the response object on success and returns silently on failure. The graceful degradation pattern is consistently applied across all failure modes (no chain match, missing peer address, openChannel throw, polling timeout, getChannelState throw).
- **`NostrSpspClient.ts`** extension is minimal and backward-compatible. The settlement result mapping from `SpspResponse` fields to `SettlementNegotiationResult` is clean.
- **`types.ts`** adds 6 well-documented interfaces that align exactly with the story's data model specification.
- All new exports are correctly wired through `spsp/index.ts` and `index.ts`.
- Constructor backward compatibility maintained via optional positional parameters.

### Refactoring Performed

None required. The implementation follows established patterns and is clean as-is.

### Compliance Check

- Coding Standards: ✓ Follows existing patterns (JSDoc, AAA test pattern, import style)
- Project Structure: ✓ Co-located test files, correct barrel exports, new file in correct directory
- Testing Strategy: ✓ 29 new tests across 3 files, mocked external dependencies, AAA pattern
- All ACs Met: ✓ All 12 acceptance criteria are implemented and tested

### Improvements Checklist

- [x] All 6 interfaces properly typed with JSDoc comments
- [x] Pure functions extracted to dedicated module
- [x] Backward compatibility preserved for both server and client
- [x] Graceful degradation for all 5 failure scenarios
- [x] Full test coverage for happy path and error handling
- [ ] Consider making `pollInterval` configurable via `SettlementNegotiationConfig` (currently hardcoded to 1000ms — minor, not blocking)
- [ ] Consider adding a multi-iteration polling test with a `channelOpenTimeout` > `pollInterval` to verify loop behavior (current timeout test exits after first iteration since 100ms < 1000ms poll interval — functional but doesn't exercise iteration)

### Security Review

No security concerns. All SPSP payloads including settlement fields remain NIP-44 encrypted end-to-end. The `ConnectorChannelClient` is an interface only — no HTTP implementation in this package. No blockchain SDK imports. `peerId` derivation follows the established `nostr-{pubkey.slice(0, 16)}` convention from `bootstrap.ts`.

### Performance Considerations

No performance concerns. The `negotiateSettlementChain()` function is O(n) where n is the size of chain lists (typically 1-5 entries). The polling loop has configurable timeout and fixed 1s interval which is appropriate for on-chain confirmation times. The polling adds latency to SPSP responses only when settlement negotiation is enabled.

### Files Modified During Review

None — no refactoring was performed.

### Gate Status

Gate: PASS → docs/qa/gates/7.3-implement-settlement-negotiation-spsp-server.yml

### Recommended Status

✓ Ready for Done

## File List

| File | Action | Description |
|------|--------|-------------|
| `packages/core/src/types.ts` | Modified | Add ConnectorChannelClient, OpenChannelParams, OpenChannelResult, ChannelState, SettlementNegotiationConfig, SettlementNegotiationResult interfaces |
| `packages/core/src/spsp/settlement.ts` | Created | Pure functions: negotiateSettlementChain(), resolveTokenForChain() |
| `packages/core/src/spsp/settlement.test.ts` | Created | Unit tests for settlement negotiation pure functions |
| `packages/core/src/spsp/NostrSpspServer.ts` | Modified | Add settlementConfig + channelClient params, settlement negotiation in processRequest() |
| `packages/core/src/spsp/NostrSpspServer.test.ts` | Modified | Add tests for settlement negotiation happy path, error handling, backward compat |
| `packages/core/src/spsp/NostrSpspClient.ts` | Modified | Add settlementInfo to requestSpspInfo options, extend return type with settlement result |
| `packages/core/src/spsp/NostrSpspClient.test.ts` | Modified | Add tests for settlement info passing and settlement result parsing |
| `packages/core/src/spsp/index.ts` | Modified | Export negotiateSettlementChain, resolveTokenForChain |
| `packages/core/src/index.ts` | Modified | Export new types (ConnectorChannelClient, etc.) and settlement functions |

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-08 | 0.1 | Initial story draft | SM (Claude Opus 4.6) |
| 2026-02-08 | 0.2 | Fix AC 10 wording (config object not env vars), add peerAddress graceful degradation to Task 6 + test to Task 10, reframe Task 13 as verification step | QA (Claude Opus 4.6) |
| 2026-02-08 | 1.0 | Implementation complete — all 14 tasks done, 29 new tests (919 total), 0 failures, no new lint errors | Dev (Claude Opus 4.6) |

## Dev Agent Record

### Agent Model Used
Claude Opus 4.6

### Debug Log References
No debug issues encountered.

### Completion Notes
- 919 tests passing (29 new tests added), 0 failures
- ESLint: 3 pre-existing errors (none introduced by Story 7.3) — same as Stories 7.1/7.2
- No new dependencies added
- All 6 new interfaces (`ConnectorChannelClient`, `OpenChannelParams`, `OpenChannelResult`, `ChannelState`, `SettlementNegotiationConfig`, `SettlementNegotiationResult`) exported from package root
- `negotiateSettlementChain()` and `resolveTokenForChain()` are pure functions in `settlement.ts` — no I/O, no side effects
- `NostrSpspServer` constructor is backward compatible — new `settlementConfig` and `channelClient` params are optional (4th and 5th position)
- `NostrSpspClient.requestSpspInfo()` options type extended with optional `settlementInfo` — backward compatible
- `NostrSpspClient.requestSpspInfo()` return type extended to `SpspInfo & { settlement?: SettlementNegotiationResult }` — backward compatible (existing code using `SpspInfo` will still work)
- Channel state polling uses 1s interval with configurable timeout (default 30s, tests use 100ms)
- Graceful degradation works correctly for all failure modes: no chain match, missing peer address, openChannel throw, polling timeout, getChannelState throw
