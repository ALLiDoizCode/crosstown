# Story 3.2: Mutual Followers Count

## Status

Done

## Story

**As an** agent developer,
**I want** to count mutual followers between two pubkeys,
**so that** I can use shared connections as a trust signal.

## Acceptance Criteria

1. `getMutualFollowers(pubkeyA: string, pubkeyB: string): Promise<string[]>` method added
2. Returns array of pubkeys that follow both A and B
3. Method efficiently queries follower lists for both pubkeys
4. Unit tests verify correct intersection calculation

## Tasks / Subtasks

- [x] Task 1: Understand follower query pattern (AC: 3)
  - [x] Review NIP-02 spec for follower discovery
  - [x] Note: Followers are found via kind:3 events where the `p` tag contains the target pubkey (NOT the `authors` field)
  - [x] Create private method `getFollowersForPubkey(pubkey: string): Promise<string[]>`
  - [x] Query kind:3 events with filter `'#p': [pubkey]` to find all events that contain the target in their p tags
  - [x] Extract `pubkey` (author) from each matching event - these are the followers

- [x] Task 2: Implement getMutualFollowers method (AC: 1, 2, 3)
  - [x] Add method signature: `getMutualFollowers(pubkeyA: string, pubkeyB: string): Promise<string[]>`
  - [x] Validate both pubkeys using existing `validatePubkey()` method
  - [x] Handle edge case: if pubkeyA === pubkeyB, return empty array (no mutual followers with self)
  - [x] Query followers for both pubkeys in parallel using `Promise.all()`
  - [x] Compute intersection of the two follower sets
  - [x] Return sorted array of mutual follower pubkeys (for deterministic output)

- [x] Task 3: Optimize follower queries (AC: 3)
  - [x] Use efficient Set operations for intersection calculation
  - [x] Query both follower lists in parallel (not sequentially)
  - [x] Handle relay failures gracefully (return empty array on failure, don't throw)

- [x] Task 4: Update exports (AC: 1)
  - [x] No new exports needed - method is added to existing `SocialTrustManager` class
  - [x] Verify `SocialTrustManager` is already exported from `packages/core/src/index.ts`

- [x] Task 5: Write unit tests for basic functionality (AC: 1, 2, 4)
  - [x] Add tests to existing `packages/core/src/trust/SocialTrustManager.test.ts`
  - [x] Test method returns empty array when no mutual followers exist
  - [x] Test method returns correct pubkeys when mutual followers exist
  - [x] Test method returns all mutual followers when multiple exist

- [x] Task 6: Write unit tests for edge cases (AC: 4)
  - [x] Test same pubkey for A and B returns empty array
  - [x] Test invalid pubkey format throws `TrustCalculationError`
  - [x] Test relay returning no events returns empty array
  - [x] Test handles case where one pubkey has no followers

- [x] Task 7: Write unit tests for intersection calculation (AC: 2, 4)
  - [x] Test A has followers [X, Y, Z], B has followers [Y, Z, W] → returns [Y, Z]
  - [x] Test A has followers [X], B has followers [Y] → returns []
  - [x] Test A has followers [X, Y], B has followers [X, Y] → returns [X, Y]

- [x] Task 8: Write unit tests for parallel queries (AC: 3, 4)
  - [x] Test both follower queries are made in parallel
  - [x] Test handles one query failing while other succeeds
  - [x] Test handles both queries failing gracefully

## Dev Notes

### Previous Story Insights
[Source: docs/stories/3.1.story.md#dev-agent-record]

From Story 3.1 implementation:
- `SocialTrustManager` class already exists with constructor and `getSocialDistance()` method
- Private `validatePubkey()` method already exists for pubkey validation
- Private `getFollowsForPubkey()` method exists - queries kind:3 by author (who someone follows)
- Uses `Promise.allSettled()` for parallel queries with graceful failure handling
- 248 tests currently passing in core package
- Test helper `createKind3Event()` already exists for creating mock events

### Key Technical Insight: Followers vs Following

**Important distinction:**
- `getFollowsForPubkey(pubkey)` → Returns who the pubkey **follows** (filter: `authors: [pubkey]`)
- `getFollowersForPubkey(pubkey)` → Returns who **follows** the pubkey (filter: `'#p': [pubkey]`)

For mutual followers, we need the **followers** of both pubkeys - people who follow them. This requires a different query pattern.

### NIP-02 Follower Query Pattern
[Source: nostr-tools documentation, NIP-02]

To find who follows a given pubkey, query for kind:3 events where the pubkey appears in a `p` tag:

```typescript
const filter: Filter = {
  kinds: [3],
  '#p': [pubkey],  // Events that contain this pubkey in p tags
};

const events = await this.pool.querySync(this.relayUrls, filter);

// Each event's pubkey (author) is a follower
const followers = events.map(event => event.pubkey);
return [...new Set(followers)];  // Deduplicate
```

Note: The `#p` filter syntax is how nostr-tools represents tag filters (NIP-01).

### Project Structure
[Source: docs/architecture/9-source-tree.md]

Files to modify for this story:
```
packages/core/src/
├── trust/
│   ├── SocialTrustManager.ts           # Add getMutualFollowers method (modify)
│   └── SocialTrustManager.test.ts      # Add tests (modify)
```

No new files need to be created - just extending the existing class.

### Data Models
[Source: docs/architecture/4-data-models.md#45-trustscore]

**TrustScore** (to be implemented in Story 3.3):
```typescript
interface TrustScore {
  score: number;           // 0-1 overall trust score
  socialDistance: number;  // From Story 3.1
  mutualFollowerCount: number;  // Count from THIS STORY
  breakdown: object;
}
```

Story 3.2 provides the `mutualFollowerCount` component. The method returns the actual pubkeys, and `.length` gives the count.

### Algorithm Design

**Mutual Followers Intersection:**
```typescript
async getMutualFollowers(pubkeyA: string, pubkeyB: string): Promise<string[]> {
  // Validate inputs
  this.validatePubkey(pubkeyA);
  this.validatePubkey(pubkeyB);

  // Edge case: same pubkey
  if (pubkeyA === pubkeyB) {
    return [];
  }

  // Query followers in parallel
  const [followersA, followersB] = await Promise.all([
    this.getFollowersForPubkey(pubkeyA),
    this.getFollowersForPubkey(pubkeyB),
  ]);

  // Compute intersection using Set
  const setB = new Set(followersB);
  const mutual = followersA.filter(pk => setB.has(pk));

  // Sort for deterministic output
  return mutual.sort();
}
```

**Time Complexity:** O(n + m) where n, m are follower counts
**Space Complexity:** O(m) for the Set

### Error Handling
[Source: docs/architecture/11-error-handling-strategy.md]

- Invalid pubkey format → throw `TrustCalculationError` (reuse existing `validatePubkey()`)
- Relay query failures → handle gracefully, return empty array (same pattern as `getFollowsForPubkey()`)
- No secrets involved - only public follow lists

### Coding Standards
[Source: docs/architecture/12-coding-standards.md]

| Element | Convention | Example |
|---------|------------|---------|
| Methods | camelCase | `getMutualFollowers` |
| Private methods | camelCase | `getFollowersForPubkey` |
| Test files | Same name with `.test.ts` suffix | Already exists |

**Critical Rules:**
- Never use `any` - use `unknown` and type guards
- Always mock SimplePool in tests - no live relay dependencies
- Follow AAA pattern (Arrange, Act, Assert)

### Testing Requirements
[Source: docs/architecture/13-test-strategy-and-standards.md]

**Framework:** Vitest 1.x

**Mocking pattern from Story 3.1:**
```typescript
import { vi, describe, it, expect, beforeEach } from 'vitest';
import type { SimplePool } from 'nostr-tools/pool';
import type { VerifiedEvent } from 'nostr-tools/pure';

// Reuse existing createKind3Event helper
function createKind3Event(
  pubkey: string,
  followedPubkeys: string[],
  created_at = Math.floor(Date.now() / 1000)
): VerifiedEvent {
  return {
    id: `event-${pubkey.slice(0, 8)}`,
    pubkey,
    kind: 3,
    content: '',
    tags: followedPubkeys.map((pk) => ['p', pk]),
    created_at,
    sig: 'mock-sig',
  } as unknown as VerifiedEvent;
}

// Mock follower query response (events that follow target)
// If X follows target, return kind:3 event from X containing target in p tags
mockPool.querySync.mockResolvedValueOnce([
  createKind3Event(followerX, [targetPubkey, otherPubkey]),
  createKind3Event(followerY, [targetPubkey]),
]);
```

**Test Requirements:**
- Follow AAA pattern (Arrange, Act, Assert)
- Mock all SimplePool calls
- Test success and error paths
- >80% coverage for new functionality

### Performance Considerations

**Query Efficiency:**
- Follower queries can return many events (popular accounts have many followers)
- Relay may have limits on how many events are returned
- Consider adding optional `limit` parameter in future stories (not needed for MVP)

**Parallel Queries:**
- Both follower lists are queried in parallel
- If one fails, the other can still succeed (intersection with empty set = empty)

### Security Considerations
[Source: docs/architecture/14-security.md]

- Validate all pubkeys as 64-character hex before use
- Only queries public follow lists (kind:3 events) - no secrets involved
- Results are public information (who follows whom)

## Dev Agent Record

### Agent Model Used

Claude Opus 4.5 (claude-opus-4-5-20251101)

### File List

| File | Action | Description |
|------|--------|-------------|
| packages/core/src/trust/SocialTrustManager.ts | Modified | Added `getFollowersForPubkey()` private method and `getMutualFollowers()` public method |
| packages/core/src/trust/SocialTrustManager.test.ts | Modified | Added 15 new tests for getMutualFollowers functionality |

### Completion Notes

- Implemented `getFollowersForPubkey()` with `'#p': [pubkey]` filter pattern (distinct from existing `getFollowsForPubkey()` which uses `authors`)
- `getMutualFollowers()` uses `Promise.all()` for parallel queries, Set for O(n+m) intersection
- Returns sorted array for deterministic output
- Graceful failure handling: relay errors return empty array (no throw)
- All 263 tests pass (15 new tests added for this story)
- ESLint passes

### Debug Log References

None - no issues encountered during implementation

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-06 | 0.1 | Initial story draft | SM |
| 2026-02-06 | 0.2 | Implementation complete | Dev Agent (James) |

## QA Results

### Review Date: 2026-02-06

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall: Excellent.** The implementation demonstrates strong code quality with proper adherence to established patterns. The `getMutualFollowers()` method follows the same structural pattern as `getSocialDistance()`, maintaining consistency throughout the `SocialTrustManager` class.

Key strengths:
- Clean separation with new private `getFollowersForPubkey()` method (distinct from existing `getFollowsForPubkey()`)
- Correct use of `'#p': [pubkey]` filter pattern for follower discovery (NIP-02 compliant)
- Efficient O(n+m) intersection algorithm using Set
- Parallel queries via `Promise.all()` for both follower lists
- Deterministic sorted output for consistency
- Graceful relay failure handling (returns empty array, doesn't throw)

### Refactoring Performed

None required. The code is well-structured and follows project conventions.

### Compliance Check

- Coding Standards: ✓ Follows 12-coding-standards.md (camelCase methods, proper types, no `any`)
- Project Structure: ✓ Files in correct locations (`packages/core/src/trust/`)
- Testing Strategy: ✓ Co-located test files, AAA pattern, mocked SimplePool, comprehensive coverage
- All ACs Met: ✓ All 4 acceptance criteria verified (see traceability below)

### Acceptance Criteria Traceability

| AC | Requirement | Implementation | Test Coverage |
|----|-------------|----------------|---------------|
| AC1 | `getMutualFollowers(pubkeyA, pubkeyB): Promise<string[]>` method | `SocialTrustManager.ts:185-206` | All tests verify signature |
| AC2 | Returns array of pubkeys that follow both A and B | `SocialTrustManager.ts:201-206` (Set intersection + sort) | 3 intersection tests |
| AC3 | Efficiently queries follower lists in parallel | `SocialTrustManager.ts:196-199` (Promise.all) | 3 parallel query tests |
| AC4 | Unit tests verify correct intersection calculation | 15 new tests in test file | Full coverage |

### Improvements Checklist

- [x] New `getFollowersForPubkey()` private method correctly uses `'#p'` filter
- [x] `getMutualFollowers()` validates inputs before querying
- [x] Parallel queries using `Promise.all()` for efficiency
- [x] Set intersection for O(n+m) performance
- [x] Sorted output for deterministic results
- [x] Graceful failure handling on relay errors
- [x] 15 comprehensive tests covering all scenarios
- [x] All 263 tests pass
- [x] ESLint passes

### Security Review

No security concerns. The implementation:
- Validates all pubkey inputs before use (64-char lowercase hex)
- Only queries public follow lists (kind:3 events) - no secrets involved
- Does not expose internal relay errors to consumers
- Uses `TrustCalculationError` wrapper for invalid input errors

### Performance Considerations

The implementation is efficient:
- **Time Complexity**: O(n + m) where n, m are follower counts for each pubkey
- **Space Complexity**: O(m) for the Set used in intersection
- **Query Parallelism**: Both follower queries run concurrently via `Promise.all()`
- **Graceful Degradation**: If one query fails, intersection with empty set returns empty (correct behavior)

Note: Popular accounts may have many followers. Production deployments may want pagination/limits (documented in Dev Notes, out of scope for MVP).

### Files Modified During Review

None - no refactoring performed.

### Gate Status

**Gate: PASS** -> `docs/qa/gates/3.2-mutual-followers-count.yml`

### Recommended Status

**Ready for Done**

All acceptance criteria met, 15 new tests passing (263 total), code follows established patterns, no blocking issues identified.
